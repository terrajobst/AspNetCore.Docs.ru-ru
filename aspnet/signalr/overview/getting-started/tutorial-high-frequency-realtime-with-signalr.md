---
uid: signalr/overview/getting-started/tutorial-high-frequency-realtime-with-signalr
title: 'Учебник: В реальном времени с SignalR 2 по высокой частотой | Документация Майкрософт'
author: pfletcher
description: Этом руководстве показано, как создать веб-приложения, использующего ASP.NET SignalR для предоставления функции обмена сообщениями с высокой частотой. Высокочастотный обмена сообщениями в...
ms.author: riande
ms.date: 06/10/2014
ms.assetid: 9f969dda-78ea-4329-b1e3-e51c02210a2b
msc.legacyurl: /signalr/overview/getting-started/tutorial-high-frequency-realtime-with-signalr
msc.type: authoredcontent
ms.openlocfilehash: e710980cecf9093ea9046b5790379befb5b61841
ms.sourcegitcommit: 45ac74e400f9f2b7dbded66297730f6f14a4eb25
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/16/2018
ms.locfileid: "41836715"
---
<a name="tutorial-high-frequency-realtime-with-signalr-2"></a>Учебник: В реальном времени высокой частотой с помощью SignalR 2
====================
по [Патрик Флетчера](https://github.com/pfletcher)

[Скачать завершенный проект](http://code.msdn.microsoft.com/SignalR-20-MoveShape-Demo-6285b83a)

> Этом руководстве показано, как создать веб-приложения, использующего ASP.NET SignalR 2 для предоставления функции обмена сообщениями с высокой частотой. В этом случае обмена сообщениями высокой частотой означает обновления, которые отправляются по фиксированной ставке; в случае этого приложения, не более 10 сообщений в секунду.
> 
> В этом руководстве вы создадите приложение отображает фигуры, пользователи смогут перетаскивать. Позиция фигуры в другие подключенные браузеры будут обновлены в соответствии с положение перетаскиваемого фигуры, с помощью синхронизированного обновления.
> 
> Основные понятия, представленных в этом руководстве имеют приложений в режиме реального времени играх и других приложений моделирования.
> 
> ## <a name="software-versions-used-in-the-tutorial"></a>Версии программного обеспечения, используемые в этом руководстве
> 
> 
> - [Visual Studio 2013](https://www.microsoft.com/visualstudio/eng/2013-downloads)
> - .NET 4.5
> - SignalR версии 2
>   
> 
> 
> ## <a name="using-visual-studio-2012-with-this-tutorial"></a>С помощью Visual Studio 2012 с помощью этого руководства
> 
> 
> Чтобы использовать Visual Studio 2012 с этим руководством, сделайте следующее:
> 
> - Обновление вашей [диспетчера пакетов](http://docs.nuget.org/docs/start-here/installing-nuget) до последней версии.
> - Установка [установщик веб-платформы](https://www.microsoft.com/web/downloads/platform.aspx).
> - В установщик веб-платформы, найдите и установите **ASP.NET и Web Tools 2013.1 для Visual Studio 2012**. Это будет установки Visual Studio шаблоны для SignalR классов, таких как **центр**.
> - Некоторые шаблоны (такие как **класс запуска OWIN**) будут недоступны; для этого используйте файл класса.
> 
> 
> ## <a name="tutorial-versions"></a>Учебника по версии
> 
> Сведения о более ранних версий SignalR, см. в разделе [более старых версий SignalR](../older-versions/index.md).
> 
> ## <a name="questions-and-comments"></a>Вопросы и комментарии
> 
> Оставьте свои отзывы на том, как вам понравилось, и этот учебник и что можно улучшить в комментариях в нижней части страницы. Если у вас есть вопросы, которые не имеют отношения к руководству, их можно разместить [форум по ASP.NET SignalR](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) или [StackOverflow.com](http://stackoverflow.com/).


## <a name="overview"></a>Обзор

Этот учебник демонстрирует создание приложения, состояние объекта с границами других браузеров в режиме реального времени. Приложения, которую мы создадим называется MoveShape. На странице MoveShape будет отображаться элемент HTML Div, который пользователь может перетащить; Когда пользователь перетаскивает элемент Div, его новая позиция будет отправляться на сервер, который затем сообщает о других подключенных клиентов обновить положение фигуры в соответствии с.

![Окно приложения](tutorial-high-frequency-realtime-with-signalr/_static/image1.png)

Приложение, созданное в этом руководстве основан на демонстрацию — дэмьен Эвардс. Можно увидеть видео, содержащий этой демонстрации [здесь](https://channel9.msdn.com/Series/Building-Web-Apps-with-ASP-NET-Jump-Start/Building-Web-Apps-with-ASPNET-Jump-Start-08-Real-time-Communication-with-SignalR).

Руководства запустится, где демонстрируется способ отправки сообщений SignalR из каждого события, которое возникает при перетаскивании фигуры. Каждым подключенным клиентом обновляют положение локальная версия фигуры каждый раз при получении сообщения.

Пока приложение будет работать с помощью этого метода, это не рекомендуемый модель программирования, так как бы не ограничена количеству начало отправленных сообщений, поэтому клиенты и сервер может получить перегружены сообщений и может привести к снижению производительности . Отображаемые анимации на стороне клиента также будет несвязанном, фигура будет перемещать мгновенно каждым методом, а не перемещение плавно для каждого нового расположения. Последующих разделах этого руководства мы рассмотрим, как создать функцию таймера, который ограничивает максимальную скорость, с которой сообщения отправляются с клиента или сервера, а также как плавно перемещать фигуру между расположениями. Окончательная версия приложения, созданные в этом руководстве можно загрузить из [коллекции исходных кодов](https://code.msdn.microsoft.com/SignalR-20-MoveShape-Demo-6285b83a).

Этот учебник содержит следующие разделы:

- [Необходимые компоненты](#prerequisites)
- [Создание проекта и добавьте пакет SignalR и JQuery.UI NuGet](#createtheproject2013)
- [Создание базового приложения](#baseapp)
- [Запуск в центр, при запуске приложения](#startup2013)
- [Добавить цикл клиента](#clientloop)
- [Добавление сервера выполните циклический](#serverloop)
- [Добавление анимации на стороне клиента](#animation)
- [Дальнейшие действия](#furthersteps)

<a id="prerequisites"></a>

## <a name="prerequisites"></a>Предварительные требования

Этого учебника требуется Visual Studio 2013.

<a id="createtheproject2013"></a>

## <a name="create-the-project-and-add-the-signalr-and-jqueryui-nuget-package"></a>Создание проекта и добавьте пакет SignalR и JQuery.UI NuGet

В этом разделе мы создадим проект в Visual Studio 2013.

Далее используется Visual Studio 2013 для создания пустой веб-приложения ASP.NET и добавление библиотек SignalR и jQuery.UI:

1. В Visual Studio создайте веб-приложения ASP.NET.

    ![Создание веб-](tutorial-high-frequency-realtime-with-signalr/_static/image2.png)
2. В **новый проект ASP.NET** окне оставьте **пустой** и нажмите кнопку **Создание проекта**.

    ![Создать пустой веб-узел](tutorial-high-frequency-realtime-with-signalr/_static/image3.png)
3. В **обозревателе решений**, щелкните правой кнопкой мыши проект, выберите **Add | Класс концентратора SignalR (v2)**. Назовите класс **MoveShapeHub.cs** и добавьте его в проект. На этом шаге создается **MoveShapeHub** и добавляет в проект набор файлов сценариев и ссылки на сборки, которые поддерживают SignalR.

    > [!NOTE]
    > Можно также добавить SignalR в проект, нажав кнопку **инструменты | Диспетчер пакетов библиотеки | Консоль диспетчера пакетов** и выполнив команду:

    `install-package Microsoft.AspNet.SignalR`. 

    Если вы используете консоль для добавления SignalR, создайте класс концентратора SignalR как отдельный шаг после добавления SignalR.
4. Нажмите кнопку **инструменты | Диспетчер пакетов библиотеки | Консоль диспетчера пакетов**. В окне диспетчера пакетов выполните следующую команду:

    `Install-Package jQuery.UI.Combined`

    При этом устанавливаются библиотеки jQuery UI, который будет использоваться для анимации фигуры.
5. В **обозревателе решений** узел скриптов. Библиотеки скрипта для jQuery, jQueryUI и SignalR, отображаются в проект.

    ![Ссылки на библиотеку скрипта](tutorial-high-frequency-realtime-with-signalr/_static/image4.png)

<a id="baseapp"></a>

## <a name="create-the-base-application"></a>Создание базового приложения

В этом разделе мы создадим приложение браузера, которое отправляет расположение фигуры на сервер во время каждого события перемещения мыши. Сервер затем передает эти сведения для всех других подключенных клиентов мере их получения. Мы расширим в это приложение в следующих разделах.

1. Если вы уже создавали класс MoveShapeHub.cs в **обозревателе решений**, правой кнопкой мыши проект и выберите **добавить**, **класс...** . Назовите класс **MoveShapeHub** и нажмите кнопку **добавить**.
2. Замените код в новом **MoveShapeHub** класса следующим кодом.

    [!code-csharp[Main](tutorial-high-frequency-realtime-with-signalr/samples/sample1.cs)]

    `MoveShapeHub` Выше класс является реализацией концентратор SignalR. Как и в [начало работы с SignalR](tutorial-getting-started-with-signalr.md) руководстве концентратора есть метод, который клиенты будут вызывать напрямую. В этом случае клиент передает объект, содержащий новый координаты X и Y в фигуру, чтобы на сервере, который затем возвращает широковещательная рассылка для всех других подключенных клиентов. SignalR автоматически будет сериализовать этот объект, с помощью JSON.

    Объект, который будет отправлен клиенту (`ShapeModel`) содержит члены для хранения позиции фигуры. Версия объекта на сервере также содержит член для отслеживания хранения данных какой-либо клиент, таким образом, чтобы данного клиента не будет отправлено, свои собственные данные. Использует этот член `JsonIgnore` атрибут для предотвращения сериализации и отправки клиенту.

<a id="startup2013"></a>
## <a name="starting-the-hub-when-the-application-starts"></a>Запуск в центр, при запуске приложения

1. Затем мы настроим сопоставление концентратору при запуске приложения. В SignalR 2, это делается путем добавления класса запуска OWIN, который вызовет `MapSignalR` при класс startup `Configuration` метод выполняется при запуске OWIN. Добавляется класс запуска OWIN в обработке в режиме `OwinStartup` атрибут сборки.

    В **обозревателе решений**, щелкните правой кнопкой мыши проект, а затем нажмите кнопку **Add | Класс запуска OWIN**. Назовите класс *запуска* и нажмите кнопку **ОК**.
2. Измените содержимое Startup.cs следующим образом:

    [!code-csharp[Main](tutorial-high-frequency-realtime-with-signalr/samples/sample2.cs)]

<a id="client"></a>
## <a name="adding-the-client"></a>Добавление клиента

1. Далее мы добавим клиента. В **обозревателе решений**, щелкните правой кнопкой мыши проект, а затем нажмите кнопку **Add | Новый элемент**. В **Добавление нового элемента** диалоговом окне выберите **HTML-страницу**. Присвойте странице имя **Default.html** и нажмите кнопку **добавить**.
2. В **обозревателе решений**, щелкните правой кнопкой мыши страницу, вы только что создали и нажмите кнопку **задать в качестве начальной страницы**.
3. Замените код по умолчанию в HTML-страницы в следующем фрагменте кода.

    > [!NOTE]
    > Убедитесь, что сценарий ссылается на ниже совпадение пакеты, добавляемые в проект в папку «скрипты».

    [!code-html[Main](tutorial-high-frequency-realtime-with-signalr/samples/sample3.html)]

    Приведенный выше код HTML и JavaScript создает красный Div, вызывается фигуры, включает поведение перетаскивания фигуры, с помощью библиотеки jQuery и использует фигуры `drag` событий для отправки положение фигуры на сервер.
4. Запустите приложение, нажав клавишу F5. Скопируйте URL-адрес страницы и вставьте его в второе окно браузера. Перетащите фигуру в одном из окна браузера; следует переместить фигуру в окне браузера.

    ![Окно приложения](tutorial-high-frequency-realtime-with-signalr/_static/image5.png)

<a id="clientloop"></a>

## <a name="add-the-client-loop"></a>Добавить цикл клиента

С момента отправки расположение фигуры на каждое событие перемещения мыши создаст лишние объем сетевого трафика, сообщения от клиента должны регулироваться. Мы будем использовать javascript `setInterval` функции, чтобы настроить цикл, который отправляет на сервер по фиксированной ставке новые сведения о положении. Этот цикл — это очень простой представление цикла «игры», многократно вызванной функции, которые можно применить все функциональные возможности игр или других моделирования.

1. Обновите код клиента в HTML-страницы для сопоставления в следующем фрагменте кода.

    [!code-html[Main](tutorial-high-frequency-realtime-with-signalr/samples/sample4.html)]

    Выше обновление добавляет `updateServerModel` функцию, которая вызывается с фиксированной частотой. Эта функция отправляет на сервер данные положения всякий раз, когда `moved` флаг указывает, что новые данные позиции для отправки.
2. Запустите приложение, нажав клавишу F5. Скопируйте URL-адрес страницы и вставьте его в второе окно браузера. Перетащите фигуру в одном из окна браузера; следует переместить фигуру в окне браузера. Так как будет регулировать количество сообщений, отправляемых на сервер, анимация не будет отображаться как smooth, как описано в предыдущем разделе.

    ![Окно приложения](tutorial-high-frequency-realtime-with-signalr/_static/image6.png)

<a id="serverloop"></a>

## <a name="add-the-server-loop"></a>Добавление сервера выполните циклический

В текущем приложении сообщения, отправленные с сервера клиенту иду так часто, как их получения. Это представляет подобную проблему, так как была обнаружена на клиенте; сообщения могут отправляться чаще, чем они нужны, и соединение может быть перегружено нежелательным в результате. В этом разделе описывается, как обновить сервер для реализации таймер, который регулирует скорость исходящих сообщений.

1. Замените содержимое файла `MoveShapeHub.cs` следующим фрагментом кода.

    [!code-csharp[Main](tutorial-high-frequency-realtime-with-signalr/samples/sample5.cs)]

    Приведенный выше код разворачивается клиента, чтобы добавить `Broadcaster` класс, который регулирует поток исходящих сообщений с помощью `Timer` класс из .NET framework.

    Так как сам концентратор является временным (он создается каждый раз при необходимости), `Broadcaster` будут создаваться как единственный экземпляр. Чтобы отложить его создания, пока они не понадобятся, убедившись, что первый экземпляр концентратора полностью создан, прежде чем таймер запускается используется ленивая инициализация, (появился в .NET 4).

    Вызов клиентов `UpdateShape` функция затем перемещается за пределы центра `UpdateModel` метод, чтобы он больше не вызывается немедленно в том случае, когда входящие сообщения извлекаются. Вместо этого со скоростью 25 вызовов в секунду, будут отправляться сообщения для клиентов под управлением `_broadcastLoop` таймера изнутри `Broadcaster` класса.

    Наконец, вместо вызова метода клиента от концентратора напрямую, `Broadcaster` классу необходимо получить ссылку в настоящее время работы центр (`_hubContext`) с помощью `GlobalHost`.
2. Запустите приложение, нажав клавишу F5. Скопируйте URL-адрес страницы и вставьте его в второе окно браузера. Перетащите фигуру в одном из окна браузера; следует переместить фигуру в окне браузера. Не будет видимая разница в браузере из предыдущего раздела, но число сообщений, отправляемых клиенту будет возвращена.

    ![Окно приложения](tutorial-high-frequency-realtime-with-signalr/_static/image7.png)

<a id="animation"></a>

## <a name="add-smooth-animation-on-the-client"></a>Добавление анимации на стороне клиента

Приложения почти завершена, но можно сделать один Дополнительные улучшения, в движении фигуры на стороне клиента при переносе в ответ на сообщения сервера. Вместо того чтобы задавать положение фигуры в новое расположение, заданным на сервере, мы будем использовать библиотеку JQuery UI `animate` function для перемещения фигуры плавно между его текущим и новым позиции.

1. Обновление клиента `updateShape` метод для поиска, такие как выделенный ниже код:

    [!code-html[Main](tutorial-high-frequency-realtime-with-signalr/samples/sample6.html?highlight=33-40)]

    Приведенный выше код перемещает фигуру из старой позиции в новую, учитывая сервером в ходе анимации интервал (в данном случае 100 миллисекунд). Все предыдущие анимацию на фигуре очищается перед началом новой анимации.
2. Запустите приложение, нажав клавишу F5. Скопируйте URL-адрес страницы и вставьте его в второе окно браузера. Перетащите фигуру в одном из окна браузера; следует переместить фигуру в окне браузера. Перемещение фигуры в другом окне должны появиться менее рывками, так как его перемещение является Интерполировать во времени, а не значение один раз на входящее сообщение.

    ![Окно приложения](tutorial-high-frequency-realtime-with-signalr/_static/image8.png)

<a id="furthersteps"></a>

## <a name="further-steps"></a>Дальнейшие действия

В этом руководстве вы узнали, как запрограммировать приложение SignalR, которое отправляет сообщения с высокой частотой между клиентами и серверами. Эта парадигма связи полезен для разработки игр и других режимов моделирования, такие как [ShootR игры, созданные с помощью SignalR](http://shootr.signalr.net).

Готовое приложение, созданное в этом руководстве можно загрузить из [коллекции исходных кодов](https://code.msdn.microsoft.com/SignalR-20-MoveShape-Demo-6285b83a).

Дополнительные сведения о концепции разработки SignalR, посетите следующие сайты SignalR исходный код и ресурсы:

- [Проект SignalR](http://signalr.net)
- [SignalR Github и примерами](https://github.com/SignalR/SignalR)
- [Вики-сайте SignalR](https://github.com/SignalR/SignalR/wiki)

Пошаговое руководство о том, как развернуть приложение SignalR в Azure, см. в разделе [с помощью SignalR с веб-приложениями в службе приложений Azure](../deployment/using-signalr-with-azure-web-sites.md). Подробные сведения о развертывании веб-проекта Visual Studio для веб-сайта Windows Azure см. в разделе [создать веб-приложение ASP.NET в службе приложений Azure](https://azure.microsoft.com/documentation/articles/web-sites-dotnet-get-started/).
