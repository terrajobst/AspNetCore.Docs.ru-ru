---
uid: mvc/overview/getting-started/getting-started-with-ef-using-mvc/advanced-entity-framework-scenarios-for-an-mvc-web-application
title: Расширенные сценарии Entity Framework 6 для 5 веб-приложение MVC (12, 12) | Документация Майкрософт
author: tdykstra
description: Пример веб-приложение университета Contoso демонстрирует создание приложения ASP.NET MVC 5, используя Entity Framework 6 Code First и Visual Studio...
ms.author: aspnetcontent
ms.date: 12/08/2014
ms.assetid: f35a9b0c-49ef-4cde-b06d-19d1543feb0b
msc.legacyurl: /mvc/overview/getting-started/getting-started-with-ef-using-mvc/advanced-entity-framework-scenarios-for-an-mvc-web-application
msc.type: authoredcontent
ms.openlocfilehash: 82fe650712d39558668ab02b7cc410ab0540d00f
ms.sourcegitcommit: b28cd0313af316c051c2ff8549865bff67f2fbb4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/05/2018
ms.locfileid: "37836698"
---
<a name="advanced-entity-framework-6-scenarios-for-an-mvc-5-web-application-12-of-12"></a>Сценарии расширенные Entity Framework 6, 5 веб-приложения MVC (12, 12)
====================
по [том Дайкстра](https://github.com/tdykstra)

[Скачать завершенный проект](http://code.msdn.microsoft.com/ASPNET-MVC-Application-b01a9fe8) или [скачать PDF](http://download.microsoft.com/download/0/F/B/0FBFAA46-2BFD-478F-8E56-7BF3C672DF9D/Getting%20Started%20with%20Entity%20Framework%206%20Code%20First%20using%20MVC%205.pdf)

> Пример веб-приложение университета Contoso демонстрирует создание приложения ASP.NET MVC 5, используя Entity Framework 6 Code First и Visual Studio 2013. Сведения о серии руководств см. в [первом руководстве серии](creating-an-entity-framework-data-model-for-an-asp-net-mvc-application.md).


В предыдущем учебнике было реализовано таблица на иерархию наследования. Этот учебник включает описываются некоторые расширенные, которые необходимо учитывать при переходе от основ разработки веб-приложений ASP.NET, использующих Entity Framework Code First. Пошаговые инструкции описаны код и с помощью Visual Studio в следующих разделах:

- [Выполняет необработанные запросы SQL](#rawsql)
- [Выполняет отключение отслеживания запросов](#notracking)
- [Изучение SQL отправки в базу данных](#sql)

В учебнике описывается несколько подразделов с вводную следуют ссылки на дополнительные сведения:

- [Репозиторий и блок рабочих шаблонов](#repo)
- [Прокси-классы](#proxies)
- [Автоматическое обнаружение изменений](#changedetection)
- [Автоматическая проверка](#validation)
- [Средства EF для Visual Studio](#tools)
- [Исходный код Entity Framework](#source)

Он также содержит следующие разделы:

- [Сводка](#summary)
- [Уведомления о доставке](#acknowledgments)
- [Примечание о VB](#vb)
- [Распространенные ошибки и решения или обходные пути для них](#errors)

Для большинства из этих разделов вы будете работать со страницами, которые уже созданы. Чтобы использовать необработанный SQL для проведения массовых обновлений вы создадите новую страницу, которая обновляет количество кредиты на сумму всех курсов в базе данных:

![Update_Course_Credits_initial_page](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image1.png)

<a id="rawsql"></a>
## <a name="performing-raw-sql-queries"></a>Выполнение необработанные SQL-запросы

Entity Framework API для Code First включает методы, которые позволяют передавать команды SQL непосредственно к базе данных. Можно выбрать один из следующих параметров.

- Используйте [DbSet.SqlQuery](https://msdn.microsoft.com/library/system.data.entity.dbset.sqlquery.aspx) метод для запросов, возвращающих типы сущностей. Возвращаемые объекты должен иметь тип, ожидаемый `DbSet` объекта и они автоматически отслеживаются контекстом базы данных пока не отключена отслеживания. (См. в разделе [AsNoTracking](https://msdn.microsoft.com/library/system.data.entity.dbextensions.asnotracking.aspx) метод.)
- Используйте [Database.SqlQuery](https://msdn.microsoft.com/library/system.data.entity.database.sqlquery.aspx) метод для запросов, возвращающих типы, не являющиеся сущностями. Возвращаемые данные не отслеживаются контекстом базы данных, даже если вы используете этот метод для извлечения типов сущностей.
- Используйте [Database.ExecuteSqlCommand](https://msdn.microsoft.com/library/gg679456.aspx) для команд не связанным с запросом.

Одним из преимуществ использования платформы Entity Framework является возможность избежать слишком тесной привязки кода к конкретному способу хранения данных. Это достигается путем автоматического создания запросов и команд SQL, что позволяет упростить написание кода. Но существуют менее в редких случаях, когда необходимо выполнить SQL-запросы, созданные вручную, и эти методы позволяют обрабатывать такие исключения.

Как и всегда при выполнении команд SQL в веб-приложении, необходимо принимать меры предосторожности для защиты сайта от атак путем внедрения кода SQL. Одним из способов защиты является применение параметризованных запросов, которые гарантируют, что строки, отправляемые веб-страницей, не могут быть интерпретированы как команды SQL. В рамках этого учебника вы будете использовать параметризованные запросы при интеграции вводимых пользователем данных в запрос.

### <a name="calling-a-query-that-returns-entities"></a>Вызов запроса, которая возвращает сущности

[DbSet&lt;TEntity&gt; ](https://msdn.microsoft.com/library/gg696460.aspx) класс предоставляет метод, который можно использовать для выполнения запроса, возвращающего сущность типа `TEntity`. Чтобы увидеть, как это работает, измените код в `Details` метод `Department` контроллера.

В *DepartmentController.cs*в `Details` метод, замените `db.Departments.FindAsync` вызов метода с `db.Departments.SqlQuery` вызова метода, как показано в следующем выделенном коде:

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample1.cs?highlight=8-14)]

Чтобы убедиться, что новый код работает правильно, выберите вкладку **Departments** (Кафедры) и щелкните **Details** (Сведения) для одной из кафедр.

![Сведения о кафедре](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image2.png)

### <a name="calling-a-query-that-returns-other-types-of-objects"></a>Вызов запроса, возвращающего другие типы объектов

Ранее вы создали таблицу статистики учащихся на странице сведений, в которой было показано число учащихся на каждую дату регистрации. Код, который делает это в *HomeController.cs* использует LINQ:

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample2.cs)]

Предположим, что вы хотите написать код, извлекающий эти данные непосредственно в SQL, а не с помощью LINQ. Для этого необходим для выполнения запроса, возвращающего отличные от сущностей, то есть необходимо использовать [Database.SqlQuery](https://msdn.microsoft.com/library/system.data.entity.database.sqlquery(v=VS.103).aspx) метод.

В *HomeController.cs*, замените оператор LINQ в `About` метод с инструкцией SQL, как показано в следующем выделенном коде:

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample3.cs?highlight=3-18)]

Откройте страницу About. На экран будут выведены те же данные, что и ранее.

![About_page](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image3.png)

### <a name="calling-an-update-query"></a>Вызов запроса на обновление

Предположим, что администраторам университета Suppose необходимо иметь возможность выполнять массовые изменения в базе данных, например изменить число зачетных баллов для каждого курса. Поскольку в университете ведется множество курсов, будет неэффективно извлекать их в виде сущностей и изменять по отдельности. В этом разделе вы реализуете веб-страницы, которая позволяет пользователю указать коэффициент, используемый для изменить число зачетных баллов для каждого курса, и вам предстоит изменения, выполнив SQL `UPDATE` инструкции. Веб-страница должна выглядеть так, как показано на следующем рисунке:

![Update_Course_Credits_initial_page](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image4.png)

В *CourseContoller.cs*, добавьте `UpdateCourseCredits` методы для `HttpGet` и `HttpPost`:

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample4.cs)]

Когда контроллер обрабатывает `HttpGet` запроса, то ничего не возвращается в `ViewBag.RowsAffected` переменной и представление отображает пустом текстовом поле и кнопка отправки, как показано на предыдущем рисунке.

Когда **обновление** кнопки, `HttpPost` вызывается метод, и `multiplier` имеет значение, введенное в текстовое поле. Код выполняет SQL, который обновляет курсы и возвращает число затронутых строк в представление в `ViewBag.RowsAffected` переменной. Когда представление получает значение, переменной, он отображает число строк, обновленных вместо текстового поля и отправить кнопки, как показано на следующем рисунке:

![Update_Course_Credits_rows_affected_page](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image5.png)

В *CourseController.cs*, щелкните правой кнопкой мыши один из `UpdateCourseCredits` методов, а затем щелкните **Добавление представления**.

![Add_View_dialog_box_for_Update_Course_Credits](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image6.png)

В *Views\Course\UpdateCourseCredits.cshtml*, замените код шаблона следующим кодом:

[!code-cshtml[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample5.cshtml)]

Выполните метод `UpdateCourseCredits`, выбрав вкладку **Courses** (Курсы), а затем добавив "/UpdateCourseCredits" в конец URL-адреса в адресной строке браузера (например, `http://localhost:50205/Course/UpdateCourseCredits`). Введите число в текстовое поле:

![Update_Course_Credits_initial_page_with_2_entered](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image7.png)

Нажмите кнопку **Обновить**. Отобразится число обработанных строк:

![Update_Course_Credits_rows_affected_page](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image8.png)

Нажмите кнопку **Back to List** (Вернуться к списку), чтобы просмотреть список курсов с измененным числом зачетных баллов.

![Courses_Index_page_showing_revised_credits](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image9.png)

Дополнительные сведения о необработанных SQL-запросы, см. в разделе [необработанные SQL-запросы](https://msdn.microsoft.com/data/jj592907) на сайте MSDN.

<a id="notracking"></a>
## <a name="no-tracking-queries"></a>и без отслеживания

Когда контекст базы данных извлекает строки таблицы и создает представляющие их объекты сущностей, по умолчанию отслеживается состояние синхронизации сущностей в памяти с содержимым базы данных. При обновлении сущности данные в памяти выступают в роли кэша. В веб-приложении такое кэширование часто не нужно, поскольку экземпляры контекста, как правило, существуют недолго (для каждого запроса создается и ликвидируется собственный экземпляр), и контекст, считывающий сущность, как правило, ликвидируется до того, как сущность будет использована снова.

Можно отключить отслеживание объектов сущностей в памяти с помощью [AsNoTracking](https://msdn.microsoft.com/library/gg679352(v=vs.103).aspx) метод. Как правило, это требуется в следующих сценариях:

- Запрос получает такой большой объем данных, отключение отслеживания может заметно повысить производительность.
- Вы хотите присоединить сущность для его обновления, но ранее полученные той же сущности для разных целей. Поскольку сущность уже отслеживается контекстом базы данных, присоединить сущность, которую требуется изменить, нельзя. Для обработки такой ситуации рекомендуется использовать `AsNoTracking` параметр с предыдущий запрос.

Пример, демонстрирующий способ использования [AsNoTracking](https://msdn.microsoft.com/library/gg679352(v=vs.103).aspx) метод, см. в разделе [более ранней версии этого учебника](../../older-versions/getting-started-with-ef-5-using-mvc-4/advanced-entity-framework-scenarios-for-an-mvc-web-application.md). Эта версия руководства не задан флаг Modified создания связывателя модели сущности в метод Edit для нее не нужны `AsNoTracking`.

<a id="sql"></a>
## <a name="examining-sql-sent-to-the-database"></a>Изучение SQL отправки в базу данных

В некоторых случаях полезно иметь возможность просмотреть фактические SQL-запросы, отправляемые в базу данных. В предыдущем руководстве вы узнали, как это сделать в коде перехватчик; Теперь вы увидите некоторые способы сделать это без написания кода перехватчик. Чтобы испытать эту возможность, будет рассмотрим простой запрос и взгляну на дальнейшие действия с его по мере добавления вариантов такого безотложной загрузки, фильтрации и сортировки.

В *контроллеров/CourseController*, замените `Index` метод следующим кодом, чтобы временно остановить Безотложная загрузка:

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample6.cs)]

Теперь установите точку останова на `return` инструкции (F9 с курсором, в этой строке). Нажмите клавишу F5, чтобы запустить проект в режиме отладки, выберите на странице индекса курсов. Когда код достигает точки останова, изучите `sql` переменной. Появится запрос, который отправляется в SQL Server. Это простой `Select` инструкции.

[!code-json[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample7.json)]

Щелкните увеличивающимися класс, чтобы просмотреть запрос в **визуализатор текста**.

![](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image10.png)

Теперь добавим стрелку раскрывающегося списка на страницу индекса курсов, чтобы пользователи могут выполнять фильтрацию определенного отдела. Нужно отсортировать курсы по названию, и потребуется указать упреждающую загрузку для `Department` свойства навигации.

В *CourseController.cs*, замените `Index` метод следующим кодом:

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample8.cs)]

Восстановление точки останова на `return` инструкции.

Метод получает выбранное значение из раскрывающегося списка в `SelectedDepartment` параметра. Если ничего не выбрано, этот параметр будет иметь значение null.

Объект `SelectList` коллекцию, содержащую все отделы передается в представление для раскрывающегося списка. Параметры, передаваемые `SelectList` конструктор укажите значение имени поля, имя текстового поля и выбранного элемента.

Для `Get` метод `Course` репозитория, код задает критерий фильтра, порядок сортировки и Безотложная загрузка для `Department` свойства навигации. Возвращает критерий фильтра всегда `true` Если ничего не выбрано в раскрывающемся списке (то есть `SelectedDepartment` имеет значение null).

В *Views\Course\Index.cshtml*, непосредственно перед открытием `table` , добавьте следующий код для создания раскрывающегося списка и кнопка отправки:

[!code-cshtml[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample9.cshtml)]

С точкой останова по-прежнему набор, откройте страницу индекса курсов. Выполните остальные указания первый раз, что код достигает точки останова, чтобы отобразить страницу в браузере. Выберите отдел в раскрывающемся списке и нажмите кнопку **фильтра**:

![Course_Index_page_with_department_selected](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image11.png)

Это время для запроса отделов для раскрывающегося списка будет первой точке останова. Пропустите и просмотрите `query` переменной очередном код достигает точки останова для см. в разделе, что `Course` запроса теперь выглядит примерно как. Вы увидите примерно следующим образом:

[!code-sql[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample10.sql)]

Вы увидите, что запрос является теперь `JOIN` запрос, который загружает `Department` вместе с данными `Course` данных, и что он включает `WHERE` предложение.

Удалить `var sql = courses.ToString()` строки.

<a id="repo"></a>

## <a name="repository-and-unit-of-work-patterns"></a>Шаблоны репозитория и единиц работы

Многие разработчики пишут код, реализующий шаблоны репозитория и единиц работы, в качестве оболочки для кода, работающего с платформой Entity Framework. Эти шаблоны позволяют создать уровень абстракции между уровнями доступа к данным и бизнес-логики приложения. Реализация таких шаблонов позволяет изолировать приложение от изменений в хранилище данных и упрощает автоматическое модульное тестирование или разработку на основе тестирования. Тем не менее написание дополнительного кода для реализации этих шаблонов не всегда лучший выбор для приложений, использующих EF, по следующим причинам:

- Класс контекста EF сам по себе изолирует код от кода хранилища данных.
- Класс контекста EF может выступать в качестве класса единиц работы для обновления базы данных, которые выполняются с помощью EF.
- В Entity Framework 6 это проще реализовать TDD без написания кода репозитория.

Дополнительные сведения о том, как реализовать репозиторий и блок рабочих шаблонов, см. в разделе [версии Entity Framework 5 этой серии руководств](../../older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application.md). Сведения о способах реализации TDD в Entity Framework 6 см. следующие ресурсы:

- [Как EF6 позволяет макетирование DbSets проще](http://thedatafarm.com/data-access/how-ef6-enables-mocking-dbsets-more-easily/)
- [Тестирование с помощью макетирования](https://msdn.microsoft.com/data/dn314429)
- [Тестирование с помощью собственных тестовых дублеров](https://msdn.microsoft.com/data/dn314431)

<a id="proxies"></a>
## <a name="proxy-classes"></a>Прокси-классы

Когда платформа Entity Framework создает экземпляры сущностей (например, при выполнении запроса), он часто создает их как экземпляры динамически создаваемого производный тип, который выступает в качестве прокси для сущности. Например см. следующие два образа отладчика. На первом изображении видно, что `student` переменная является ожидаемый `Student` введите сразу после создания экземпляра сущности. На втором изображении после EF использовался для чтения сущности student в базе данных, вы увидите прокси-класса.

![Прежде чем прокси-класс](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image12.png)

![После прокси-класс](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image13.png)

Этот класс прокси переопределяет некоторые виртуальные свойства сущности, которую нужно вставить обработчик для выполнения действий автоматически, при обращении к свойству. Одна функция, этот механизм используется для является отложенной загрузки.

В большинстве случаев не требуется учитывать такое использование учетных записей-посредников, но существуют исключения:

- В некоторых сценариях может потребоваться запретить Entity Framework создавать экземпляры прокси-сервера. Например при сериализации сущностей обычно требуется классы POCO, а не прокси-классы. Один из способов избежать сериализации — для сериализации объектов передачи данных (DTO) вместо объекта сущности, как показано в [с помощью веб-API с Entity Framework](../../../../web-api/overview/data/using-web-api-with-entity-framework/part-1.md) руководства. Другим способом является [отключить создание прокси-](https://msdn.microsoft.com/data/jj592886.aspx).
- При создании экземпляра класса сущности с помощью `new` оператор, вы не получаете экземпляр прокси-сервера. Это означает, что вы не получаете функциональные возможности, такие как отложенная загрузка и автоматическое отслеживание изменений. Обычно это хорошо; обычно не требуется отложенной загрузки, так как вы создаете новую сущность, которые не находятся в базе данных, и обычно не требуется отслеживания изменений, если явным образом пометить сущности как `Added`. Тем не менее, если вам нужен отложенную загрузку, и требуется отслеживание изменений, можно создать экземпляры этой сущности с помощью прокси- [создать](https://msdn.microsoft.com/library/gg679504.aspx) метод `DbSet` класса.
- Может потребоваться получить тип фактические сущности из прокси-типа. Можно использовать [GetObjectType](https://msdn.microsoft.com/library/system.data.objects.objectcontext.getobjecttype.aspx) метод `ObjectContext` класса для получения фактического объекта типа экземпляра типа прокси-сервера.

Дополнительные сведения см. в разделе [работа с прокси](https://msdn.microsoft.com/data/JJ592886.aspx) на сайте MSDN.

<a id="changedetection"></a>
## <a name="automatic-change-detection"></a>Автоматическое обнаружение изменений

Платформа Entity Framework определяет, как была изменена сущность (и, соответственно, какие обновления требуется отправить в базу данных), сравнивая текущие значения сущности с исходными. Исходные значения сохраняются при запросе или присоединении сущности. Ниже перечислены некоторые из методов, которые приводят к автоматическому обнаружению изменений:

- `DbSet.Find`
- `DbSet.Local`
- `DbSet.Remove`
- `DbSet.Add`
- `DbSet.Attach`
- `DbContext.SaveChanges`
- `DbContext.GetValidationErrors`
- `DbContext.Entry`
- `DbChangeTracker.Entries`

Если вы отслеживаете большое количество сущностей и вызовите один из этих методов много раз в цикле, можно получить значительно большую производительность, временно отключив автоматическое изменение обнаружения с помощью метода [autodetectchangesenabled в свойстве](https://msdn.microsoft.com/library/system.data.entity.infrastructure.dbcontextconfiguration.autodetectchangesenabled.aspx) свойство. Дополнительные сведения см. в разделе [автоматическое обнаружение изменений](https://msdn.microsoft.com/data/jj556205) на сайте MSDN.

<a id="validation"></a>
## <a name="automatic-validation"></a>Автоматическая проверка

При вызове `SaveChanges` метод, по умолчанию Entity Framework проверяет данные в все свойства всех измененных сущностей перед обновлением базы данных. Если вы обновили большое количество сущностей и вы уже проверили данные, эта работа необязателен и может сделать процесс сохранения изменений обрабатываются быстрее, временно отключив проверки. Можно сделать с помощью [ValidateOnSaveEnabled](https://msdn.microsoft.com/library/system.data.entity.infrastructure.dbcontextconfiguration.validateonsaveenabled.aspx) свойство. Дополнительные сведения см. в разделе [проверки](https://msdn.microsoft.com/data/gg193959) на сайте MSDN.

<a id="tools"></a>
## <a name="entity-framework-power-tools"></a>Entity Framework Power Tools

[Entity Framework Power Tools](https://visualstudiogallery.msdn.microsoft.com/72a60b14-1581-4b9b-89f2-846072eff19d) надстройки Visual Studio, который использовался для создания схем модели данных отображается в этих учебниках. Средства также можно выполнять другие функции, такие как создание классов сущностей на основе таблиц в существующую базу данных, которые можно использовать базы данных в режиме Code First. После установки средств в контекстные меню отображаются некоторые дополнительные параметры. Например, если щелкнуть правой кнопкой мыши класс контекста в **обозревателе решений**, вы получаете возможность создать схему. При использовании Code First нельзя изменить модель данных на диаграмме, но вы можно перемещать ресурсы, чтобы было проще понять.

![EF в контекстном меню](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image14.png)

![Схема EF](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image15.png)

<a id="source"></a>
## <a name="entity-framework-source-code"></a>Исходный код Entity Framework

Исходный код для платформы Entity Framework 6 предоставляется [GitHub](https://github.com/aspnet/EntityFramework6). Можно создавать ошибки, и у вас есть доступ свои улучшения к исходному коду EF.

Несмотря на то, что исходный код открыт, Entity Framework полностью поддерживается как продукт Microsoft. Команда Microsoft Entity Framework контролирует предложения участников, принимает их и тестирует любые изменения кода, чтобы обеспечить максимальное качество каждого выпуска.

<a id="summary"></a>
## <a name="summary"></a>Сводка

На этом завершается этой серии руководств по использованию Entity Framework в приложении ASP.NET MVC. Дополнительные сведения о том, как работать с данными, с помощью Entity Framework см. в разделе [EF страницы документации на сайте MSDN](https://msdn.microsoft.com/data/ee712907) и [доступ к данным ASP.NET — рекомендуемые ресурсы](../../../../whitepapers/aspnet-data-access-content-map.md).

Дополнительные сведения о развертывании веб-приложения после его создания см. в разделе [веб-развертывание ASP.NET — рекомендуемые ресурсы](../../../../whitepapers/aspnet-web-deployment-content-map.md) в библиотеке MSDN.

Сведения по другим вопросам, связанных с MVC, таких как проверка подлинности и авторизации, см. в разделе [MVC ASP.NET. Рекомендуемые ресурсы](../recommended-resources-for-mvc.md).

<a id="acknowledgments"></a>
## <a name="acknowledgments"></a>Благодарности

- Том Дайкстра написал исходной версии этого учебника, соавтором обновление EF 5 и написал обновление EF 6. Том — старший разработчик программирования на веб-платформы Майкрософт и группа разработки содержимого программных средств.
- [Рик Андерсон](https://blogs.msdn.com/b/rickandy/) (twitter [ @RickAndMSFT ](http://twitter.com/RickAndMSFT)) была большая часть работы, обновление в учебнике для EF 5 и MVC 4 и Соавтор книги обновление EF 6. Рик — старший разработчик программирования для Microsoft Azure и MVC.
- [Роуэн Миллер](http://www.romiller.com) и другие участники команды Entity Framework assisted с проверками кода и помогли многих проблемах отладки со миграций, которые возникли во время мы обновляли руководства для EF 5 и EF 6.

<a id="vb"></a>
## <a name="vb"></a>VB

При этом руководстве была разработана для EF 4.1, мы предоставили версии C# и VB проекта Загрузка завершена. Из-за ограничения времени и другие приоритеты мы еще не, для этой версии. При сборке проекта VB с помощью этих учебников и возможно, захотят, поделиться с другими пользователями, свяжитесь с нами.

<a id="errors"></a>
## <a name="common-errors-and-solutions-or-workarounds-for-them"></a>Распространенные ошибки и решения или обходные пути для них

### <a name="cannot-createshadow-copy"></a>Не удается создать теневую копию

Сообщение об ошибке:

> Не удается создать теневую копию "&lt;filename&gt;" Когда этот файл уже существует.


Решение

Подождите несколько секунд и обновите страницу.

### <a name="update-database-not-recognized"></a>Update-Database не распознан

Сообщение об ошибке (из `Update-Database` команду в PMC):

> Термин «Update-Database» не распознан как имя командлета, функции, файла скрипта или действующей программы. Проверьте правильность написания имени или если был задан путь, проверьте правильность пути и повторите попытку.


Решение

Закройте Visual Studio. Повторно откройте проект и повторите попытку.

### <a name="validation-failed"></a>Сбой проверки

Сообщение об ошибке (из `Update-Database` команду в PMC):

> Не удалось проверить один или несколько сущностей. Свойству «EntityValidationErrors» Дополнительные сведения см.


Решение

Одной из причин этой проблемы является ошибки проверки при `Seed` выполнения метода. См. в разделе [заполнения и отладка Entity Framework (EF) DBs](https://blogs.msdn.com/b/rickandy/archive/2013/02/12/seeding-and-debugging-entity-framework-ef-dbs.aspx) советы по отладке `Seed` метод.

### <a name="http-50019-error"></a>HTTP 500.19 ошибки

Сообщение об ошибке:

> Ошибка HTTP 500.19 — Внутренняя ошибка сервера  
> Запрошенной страницы не может быть недоступна из-за неверной конфигурации данных для страницы.


Решение

Один из способов, эта ошибка может возникнуть — от использования нескольких копий решение, каждый из них используют тот же номер порта. Как правило, эту проблему можно решить, выход из всех экземпляров Visual Studio, а затем перезагрузить проект, над которым вы работаете. Если это не поможет, попробуйте изменить номер порта. Щелкните правой кнопкой файл проекта и выберите пункт Свойства. Выберите **Web** вкладку и измените номер порта в **URL-адрес проекта** текстовое поле.

### <a name="error-locating-sql-server-instance"></a>Ошибка при обнаружении экземпляра SQL Server

Сообщение об ошибке:

> При установлении подключения к SQL Server произошла ошибка сети или ошибка экземпляра. Сервер не найден или недоступен. Проверьте правильность имени экземпляра и настройку сервера SQL Server для удаленных подключений. (поставщик: сетевые интерфейсы SQL, ошибка: 26 — ошибка при обнаружении указанного сервера или экземпляра)


Решение

Проверьте строку подключения. Если вы вручную удалили базы данных, измените имя базы данных в строке подключения.

> [!div class="step-by-step"]
> [Назад](implementing-inheritance-with-the-entity-framework-in-an-asp-net-mvc-application.md)
