---
title: Области в ASP.NET Core
author: rick-anderson
description: Сведения о том, что области — это возможность ASP.NET MVC, которая служит для объединения связанных функций в группу в виде отдельного пространства имен (для маршрутизации) и структуры папок (для представлений).
manager: wpickett
ms.author: riande
ms.date: 02/14/2017
ms.prod: asp.net-core
ms.technology: aspnet
ms.topic: article
uid: mvc/controllers/areas
ms.openlocfilehash: 61527eb350b5aba9cb37b1de5acdeae1287bf073
ms.sourcegitcommit: 48beecfe749ddac52bc79aa3eb246a2dcdaa1862
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/22/2018
---
# <a name="areas-in-aspnet-core"></a>Области в ASP.NET Core

Авторы: [Дхананджай Кумар](https://twitter.com/debug_mode) (Dhananjay Kumar) и [Рик Андерсон](https://twitter.com/RickAndMSFT) (Rick Anderson)

Области — это возможность ASP.NET MVC, которая служит для объединения связанных функций в группу в виде отдельного пространства имен (для маршрутизации) и структуры папок (для представлений). При использовании областей создается иерархия в целях маршрутизации. Для этого к `controller` и `action` добавляется еще один параметр маршрута, `area`.

Области позволяют разделить большое веб-приложение ASP.NET Core MVC на более мелкие функциональные группы. По сути, область является структурой MVC внутри приложения. В проекте MVC логические компоненты, такие как модель, контроллер и представление, находятся в разных папках, и для создания связи между этими компонентами MVC использует соглашения об именовании. Крупное приложение может быть целесообразно разделить на отдельные высокоуровневые области функциональности. Например, в приложении для электронной коммерции можно выделить несколько подразделений: для оформления заказов, выставления счетов, поиска и т. д. Каждое из них имеет собственные представления, контроллеры и модели логических компонентов. В этом сценарии можно использовать области для физического разделения бизнес-компонентов в рамках одного проекта.

Область можно определить как небольшой функциональный модуль в проекте ASP.NET Core MVC с собственным набором контроллеров, представлений и моделей.

Использовать области в проекте MVC рекомендуется в указанных ниже случаях.

* Приложение состоит из нескольких высокоуровневых функциональных частей, которые должны быть разделены логически.

* Необходимо разделить проект MVC так, чтобы с каждой функциональной областью можно было работать отдельно.

Возможности областей:

* Приложение ASP.NET Core MVC может иметь любое количество областей.

* Каждая область имеет собственные контроллеры, модели и представления.

* Позволяют разбивать большие проекты MVC на несколько высокоуровневых компонентов, с которыми можно работать по отдельности.

* Поддерживают использование нескольких контроллеров с одинаковыми именами при условии, что у них разные *области*.

Давайте рассмотрим пример, чтобы наглядно увидеть, как создаются и используются области. Допустим, есть приложение магазина, в котором имеются две отдельные группы контроллеров и представлений: Products (Продукты) и Services (Услуги). Типичная структура папок при использовании областей MVC будет выглядеть так:

* Имя проекта

  * Области

    * Продукты

      * Контроллеры

        * HomeController.cs

        * ManageController.cs

      * Представления

        * Главная страница

          * Index.cshtml

        * Управление

          * Index.cshtml

    * Службы

      * Контроллеры

        * HomeController.cs

      * Представления

        * Главная страница

          * Index.cshtml

Когда платформа MVC пытается преобразовать представление в области для просмотра, она по умолчанию выполняет поиск в следующих расположениях:

```text
/Areas/<Area-Name>/Views/<Controller-Name>/<Action-Name>.cshtml
   /Areas/<Area-Name>/Views/Shared/<Action-Name>.cshtml
   /Views/Shared/<Action-Name>.cshtml
   ```

Это расположения по умолчанию, которые можно изменить с помощью свойства `AreaViewLocationFormats` объекта `Microsoft.AspNetCore.Mvc.Razor.RazorViewEngineOptions`.

Например, в приведенном ниже коде папка с именем Areas была переименована в Categories.

```csharp
services.Configure<RazorViewEngineOptions>(options =>
   {
       options.AreaViewLocationFormats.Clear();
       options.AreaViewLocationFormats.Add("/Categories/{2}/Views/{1}/{0}.cshtml");
       options.AreaViewLocationFormats.Add("/Categories/{2}/Views/Shared/{0}.cshtml");
       options.AreaViewLocationFormats.Add("/Views/Shared/{0}.cshtml");
   });
   ```

Следует заметить, что в данном случае важность представляет только структура папки *Views*. Содержимое остальных папок, таких как *Controllers* и *Models*, **не** имеет значения. Например, папок *Controllers* и *Models* могло бы и не быть. Связано это с тем, что содержимое папок *Controllers* и *Models* — это всего лишь код, который компилируется в библиотеку DLL, в то время как содержимое папки *Views* не компилируется, пока не будет выполнен запрос к представлению.

Определив иерархию папок, необходимо сообщить платформе MVC, что каждый контроллер связан с областью. Для этого имя контроллера декорируется атрибутом `[Area]`.

```csharp
...
   namespace MyStore.Areas.Products.Controllers
   {
       [Area("Products")]
       public class HomeController : Controller
       {
           // GET: /Products/Home/Index
           public IActionResult Index()
           {
               return View();
           }

           // GET: /Products/Home/Create
           public IActionResult Create()
           {
               return View();
           }
       }
   }
   ```

Создайте определение маршрутов для новых областей. В статье [Маршрутизация к действиям контроллера](routing.md) подробно описывается, как создаются определения маршрутов, включая различия в использовании маршрутов на основе соглашений и на основе атрибутов. В этом примере мы используем маршрут на основе соглашения. Для этого откройте файл *Startup.cs* и измените его, добавив приведенное ниже определение именованного маршрута `areaRoute`.

```csharp
...
   app.UseMvc(routes =>
   {
     routes.MapRoute(
         name: "areaRoute",
         template: "{area:exists}/{controller=Home}/{action=Index}/{id?}");

     routes.MapRoute(
         name: "default",
         template: "{controller=Home}/{action=Index}/{id?}");
   });
   ```

При переходе по адресу `http://<yourApp>/products` будет вызван метод действия `Index` контроллера `HomeController` в области `Products`.

## <a name="link-generation"></a>Создание ссылок

* Создание ссылок на основе действия из относящегося к области контроллера, которые указывают на другое действие в том же контроллере.

  Допустим, путь текущего запроса имеет вид `/Products/Home/Create`.

  Синтаксис HtmlHelper: `@Html.ActionLink("Go to Product's Home Page", "Index")`

  Синтаксис TagHelper: `<a asp-action="Index">Go to Product's Home Page</a>`

  Обратите внимание на то, что указывать здесь значения area и controller не нужно, так как они уже доступны в контексте текущего запроса. Подобные значения называются значениями `ambient`.

* Создание ссылок на основе действия из относящегося к области контроллера, которые указывают на другое действие в другом контроллере.

  Допустим, путь текущего запроса имеет вид `/Products/Home/Create`.

  Синтаксис HtmlHelper: `@Html.ActionLink("Go to Manage Products Home Page", "Index", "Manage")`

  Синтаксис TagHelper: `<a asp-controller="Manage" asp-action="Index">Go to Manage Products Home Page</a>`

  Обратите внимание на то, что здесь используется значение окружение для area, но значение controller задано явным образом выше.

* Создание ссылок на основе действия из относящегося к области контроллера, которые указывают на другое действие в другом контроллере и другой области.

  Допустим, путь текущего запроса имеет вид `/Products/Home/Create`.

  Синтаксис HtmlHelper: `@Html.ActionLink("Go to Services Home Page", "Index", "Home", new { area = "Services" })`

  Синтаксис TagHelper: `<a asp-area="Services" asp-controller="Home" asp-action="Index">Go to Services Home Page</a>`

  Обратите внимание на то, что здесь значения окружения не используются.

* Создание ссылок на основе действия из относящегося к области контроллера, которые указывают на другое действие в другом контроллере, **не** относящемся к области.

  Синтаксис HtmlHelper: `@Html.ActionLink("Go to Manage Products  Home Page", "Index", "Home", new { area = "" })`

  Синтаксис TagHelper: `<a asp-area="" asp-controller="Manage" asp-action="Index">Go to Manage Products Home Page</a>`

  Так как нужно создать ссылки на действие контроллера, не входящего в область, здесь значение окружения для area очищается.

## <a name="publishing-areas"></a>Публикация областей

Все файлы `*.cshtml` и `wwwroot/**` публикуются в каталоге выходных данных при включении элемента `<Project Sdk="Microsoft.NET.Sdk.Web">` в файл *CSPROJ*.
