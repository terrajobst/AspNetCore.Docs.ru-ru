---
title: Проверка модели в ASP.NET Core MVC
author: rachelappel
description: Сведения о проверке модели в ASP.NET Core MVC
ms.author: riande
ms.date: 12/18/2016
uid: mvc/models/validation
ms.openlocfilehash: 19202ffce2ce5394824b401780ce750ef7852bf7
ms.sourcegitcommit: a1afd04758e663d7062a5bfa8a0d4dca38f42afc
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/20/2018
ms.locfileid: "36278896"
---
# <a name="model-validation-in-aspnet-core-mvc"></a>Проверка модели в ASP.NET Core MVC

Автор: [Рэйчел Аппель](https://github.com/rachelappel) (Rachel Appel)

## <a name="introduction-to-model-validation"></a>Общие сведения о проверке модели

Перед сохранением данных в базе данных приложение должно проверить их. Данные должны быть проверены на наличие возможных угроз безопасности, правильность форматирования по типу и размеру и соответствие правилам. Проверка необходима, хотя она может быть избыточной, а ее реализация трудоемкой. В MVC проверка производится как в клиенте, так и на сервере.

К счастью, в .NET проверка абстрагирована с помощью атрибутов проверки. Они содержат код проверки, что сокращает объем кода, который необходимо написать.

[Просмотреть или скачать образец с GitHub](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/models/validation/sample).

## <a name="validation-attributes"></a>Атрибуты проверки

Атрибуты проверки — это способ настройки проверки модели таким образом, чтобы она по существу была похожа на проверку полей в таблицах базы данных. Сюда входят ограничения, например назначение типов данных или обязательных полей. Другие виды проверок включают в себя применение шаблонов к данным, таких как шаблоны кредитной карты, номера телефона или адреса электронной почты, для реализации бизнес-правил. Атрибуты проверки значительно упрощают применение таких требований.

Ниже приведена аннотированная модель `Movie` из приложения, которое сохраняет сведения о фильмах и телепередачах. Большинство свойств являются обязательными, а к некоторым строковым свойствам предъявляются требования к длине. Кроме того, для свойства `Price` действует ограничение в виде числового диапазона (от 0 до 999,99 долл.), а также применяется пользовательский атрибут проверки.

[!code-csharp[](validation/sample/Movie.cs?range=6-29)]

Ознакомление с моделью позволяет понять правила в отношении данных в приложении, что упрощает работу с кодом. Ниже приведен ряд популярных встроенных атрибутов проверки.

* `[CreditCard]`: проверяет, имеет ли свойство формат кредитной карты.

* `[Compare]`: проверяет, совпадают ли два свойства модели.

* `[EmailAddress]`: проверяет, имеет ли свойство формат адреса электронной почты.

* `[Phone]`: проверяет, имеет ли свойство формат номера телефона.

* `[Range]`: проверяет, находится ли значение свойства в указанном диапазоне.

* `[RegularExpression]`: проверяет, соответствуют ли данные указанному регулярному выражению.

* `[Required]`: делает свойство обязательным.

* `[StringLength]`: проверяет, не превышает ли длина строкового свойства заданное максимальное значение.

* `[Url]`: проверяет, имеет ли свойство формат URL-адреса.

MVC поддерживает любые атрибуты, производные от `ValidationAttribute`, в целях проверки. Многие полезные атрибуты проверки можно найти в пространстве имен [System.ComponentModel.DataAnnotations](/dotnet/api/system.componentmodel.dataannotations).

Возможны ситуации, когда возможностей, предоставляемых встроенными атрибутами, недостаточно. В таких случаях можно создать пользовательские атрибуты проверки, производные от `ValidationAttribute`, или изменить модель так, чтобы она реализовывала интерфейс `IValidatableObject`.

## <a name="notes-on-the-use-of-the-required-attribute"></a>Примечания об использовании атрибута Required

[Типы значений](/dotnet/csharp/language-reference/keywords/value-types), не допускающие значение null (например, `decimal`, `int`, `float` и `DateTime`), являются обязательными и не требуют атрибута `Required`. Приложение не выполняет проверок на стороне сервера для не допускающих значения NULL типов, которые помечены как `Required`.

Привязка модели MVC, которая не связана с проверкой и атрибутами проверки, отклоняет отправленные поля формы, если они содержат пустое значение или пробел для типа, не допускающего значение NULL. Если целевое свойство не имеет атрибута `BindRequired`, привязка модели игнорирует отсутствие данных для типов, не допускающих значения NULL, когда поле формы отсутствует во входящих данных формы.

[Атрибут BindRequired](/dotnet/api/microsoft.aspnetcore.mvc.modelbinding.bindrequiredattribute) (см. также раздел [Настройка поведения привязки модели с помощью атрибутов](xref:mvc/models/model-binding#customize-model-binding-behavior-with-attributes)) полезен для обеспечения полноты данных в форме. Если он применяется к свойству, система привязки модели требует наличия значения у этого свойства. Если он применяется к типу, система привязки модели требует наличия значений у всех свойств этого типа.

Если вы используете [тип Nullable\<T>](/dotnet/csharp/programming-guide/nullable-types/) (например, `decimal?` или `System.Nullable<decimal>`) и помечаете его как `Required`, проверка проводится на стороне сервера так, как если бы свойство было стандартным типом, допускающим значение NULL (например, `string`).

Проверка на стороне клиента требует значения для поля формы, соответствующего свойству модели, которой помечено как `Required`, и для не допускающего значения NULL свойства, которое не помечено как `Required`. Атрибут `Required` можно использовать для управления сообщением об ошибке проверки на стороне клиента.

## <a name="model-state"></a>Состояние модели

Состояние модели представляет ошибки проверки в переданных значениях HTML-формы.

MVC будет продолжать проверять поля, пока не будет достигнуто максимальное число ошибок (по умолчанию 200). Это число можно изменить, вставив следующий код в метод `ConfigureServices` в файле *Startup.cs*:

[!code-csharp[](validation/sample/Startup.cs?range=27)]

## <a name="handling-model-state-errors"></a>Обработка ошибок состояния модели

Проверка модели проводится перед вызовом каждого действия контроллера. Метод действия отвечает за проверку свойства `ModelState.IsValid` и соответствующую реакцию. Во многих случаях правильной реакцией является возврат ответа об ошибке, который в идеале должен содержать сведения о причине непройденной проверки модели.

В некоторых приложениях соблюдается стандартное соглашение об обработке ошибок проверки модели. В этом случае подходящим местом для реализации такой политики может быть фильтр. Следует проверить, как выполняются действия при допустимых и недопустимых состояниях модели.

## <a name="manual-validation"></a>Проверка вручную

После выполнения привязки и проверки модели может потребоваться повторить некоторые части этого процесса. Например, пользователь мог ввести текст в поле, требующем целочисленного значения, или необходимо вычислить значение для свойства модели.

В этом случае может потребоваться выполнить проверку вручную. Для этого вызовите метод `TryValidateModel`, как показано ниже.

[!code-csharp[](validation/sample/MoviesController.cs?range=52)]

## <a name="custom-validation"></a>Пользовательская проверка

Атрибуты проверки удовлетворяют большинство потребностей. Однако некоторые правила проверки могут быть характерны только для вашей организации. Ваши правила могут не относиться к стандартным способам проверки данных, таким как настройка поля как обязательного или обеспечение вхождения его значения в определенный диапазон. В таких ситуациях отличным решением являются пользовательские атрибуты проверки. Создать собственные атрибуты проверки в MVC легко. Просто создайте атрибут, производный от `ValidationAttribute`, и переопределите метод `IsValid`. Метод `IsValid` принимает два параметра: объект с именем *value* и объект `ValidationContext` с именем *validationContext*. Объект *Value* ссылается на фактическое значение поля, которое проверяет пользовательский атрибут проверки.

Согласно бизнес-правилу, в приведенном ниже примере пользователи не могут выбирать жанр *Classic* (Классическое) для фильмов, вышедших после 1960 года. Атрибут `[ClassicMovie]` сначала проверяет жанр, а затем, если он имеет значение Classic, проверяет дату выхода: позднее ли она 1960 года. Если фильм вышел после 1960 года, проверка завершается неудачно. Атрибут принимает целочисленный параметр, представляющий год, который можно использовать для проверки данных. Значение параметра можно получать в конструкторе атрибута, как показано ниже.

[!code-csharp[](validation/sample/ClassicMovieAttribute.cs?range=9-28)]

Приведенная выше переменная `movie` представляет объект `Movie`, который содержит проверяемые данные из переданной формы. В этом случае код проверки проверяет дату и жанр в методе `IsValid` класса `ClassicMovieAttribute` согласно правилам. После успешной проверки `IsValid` возвращает код `ValidationResult.Success`. Если проверка завершается неудачно, возвращается `ValidationResult` с сообщением об ошибке:

[!code-csharp[](validation/sample/ClassicMovieAttribute.cs?range=55-58)]

Когда пользователь изменяет поле `Genre` и отправляет форму, метод `IsValid` атрибута `ClassicMovieAttribute` проверяет, является ли фильм классическим. Как и в случае с любым встроенным атрибутом, атрибут `ClassicMovieAttribute` следует применять к свойству, например `ReleaseDate`, для проведения проверки, как показано в предыдущем примере кода. Так как этот пример работает только с типами `Movie`, лучше использовать интерфейс `IValidatableObject`, как описано в следующем абзаце.

Кроме того, этот же код можно добавить в модель, реализовав метод `Validate` интерфейса `IValidatableObject`. Пользовательские атрибуты проверки хорошо подходят для проверки отдельных свойств, однако для реализации проверки на уровне класса можно реализовать интерфейс `IValidatableObject`, как показано ниже.

[!code-csharp[](validation/sample/MovieIValidatable.cs?range=32-40)]

## <a name="client-side-validation"></a>Проверка на стороне клиента

Проверка на стороне клиента очень удобна для пользователей. Она экономит время, которое в противном случае тратилось бы на круговой путь к серверу. С точки зрения бизнеса, даже доли секунды, умножаемые в сотни раз каждый день, позволяют значительно сократить расходуемое время, деньги и усилия. Простая и немедленная проверка позволяет пользователям работать эффективнее и повышает точность входных и выходных данных.

Для проверки на стороне клиента необходимо иметь представление с правильными ссылками на скрипты JavaScript, как показано ниже.

[!code-cshtml[](validation/sample/Views/Shared/_Layout.cshtml?range=37)]

[!code-cshtml[](validation/sample/Views/Shared/_ValidationScriptsPartial.cshtml)]

Скрипт [ненавязчивой проверки jQuery](https://github.com/aspnet/jquery-validation-unobtrusive) — это настраиваемая интерфейсная библиотека Майкрософт, которая основана на популярном подключаемом модуле [jQuery Validate](https://jqueryvalidation.org/). Без скрипта ненавязчивой проверки jQuery одну и ту же логику проверки приходилось бы реализовывать в двух местах: в атрибутах проверки для свойств модели на стороне сервера, а затем еще раз в скриптах на стороне клиента (примеры метода [`validate()`](https://jqueryvalidation.org/validate/) jQuery Validate демонстрируют, насколько сложным это может быть). Вместо этого [вспомогательные функции тегов](xref:mvc/views/tag-helpers/intro) и [вспомогательные функции HTML](xref:mvc/views/overview) платформы MVC могут использовать атрибуты проверки и метаданные типов из свойств модели для обработки [атрибутов данных](http://w3c.github.io/html/dom.html#embedding-custom-non-visible-data-with-the-data-attributes) HTML 5 в элементах форм, требующих проверки. MVC создает атрибуты `data-` как для встроенных, так и для пользовательских атрибутов. Затем скрипт ненавязчивой проверки jQuery анализирует эти атрибуты `data-` и передает логику в подключаемый модуль jQuery Validate, по сути копируя логику проверки на стороне сервера в клиент. Ошибки проверки могут выводиться в клиенте с помощью соответствующих вспомогательных функций тегов, как показано ниже.

[!code-cshtml[](validation/sample/Views/Movies/Create.cshtml?highlight=4,5&range=19-25)]

Приведенные выше вспомогательные функции тегов обрабатывают представленный ниже код HTML. Обратите внимание на то, что атрибуты `data-` в выходных данных HTML соответствуют атрибутам проверки для свойства `ReleaseDate`. Приведенный ниже атрибут `data-val-required` содержит сообщение об ошибке, которое выводится, если пользователь не заполнил поле даты выхода. Скрипт ненавязчивой проверки jQuery передает это значение в метод [`required()`](https://jqueryvalidation.org/required-method/) подключаемого модуля jQuery Validate, который затем выводит это сообщение в соответствующем элементе **\<span>**.

```html
<form action="/Movies/Create" method="post">
    <div class="form-horizontal">
        <h4>Movie</h4>
        <div class="text-danger"></div>
        <div class="form-group">
            <label class="col-md-2 control-label" for="ReleaseDate">ReleaseDate</label>
            <div class="col-md-10">
                <input class="form-control" type="datetime"
                data-val="true" data-val-required="The ReleaseDate field is required."
                id="ReleaseDate" name="ReleaseDate" value="" />
                <span class="text-danger field-validation-valid"
                data-valmsg-for="ReleaseDate" data-valmsg-replace="true"></span>
            </div>
        </div>
    </div>
</form>
```

Проверка на стороне клиента не позволяет отправлять форму, пока ее данные не будут допустимыми. При нажатии кнопки "Отправить" выполняется код JavaScript, который либо отправляет форму, либо выводит сообщения об ошибках.

MVC определяет значения атрибутов типа на основе типа данных .NET свойства, который может быть переопределен с помощью атрибутов `[DataType]`. Базовый атрибут `[DataType]` не выполняет реальную проверку на стороне сервера. Браузеры выбирают свои сообщения об ошибках и выводят их предпочтительным способом, однако пакет ненавязчивой проверки jQuery может переопределять эти сообщения и отображать их единообразно. Это особенно очевидно проявляется, когда пользователи применяют подклассы `[DataType]`, такие как `[EmailAddress]`.

### <a name="add-validation-to-dynamic-forms"></a>Добавление проверки к динамическим формам

Так как скрипт ненавязчивой проверки jQuery передает логику и параметры проверки в подключаемый модуль jQuery Validate при первой загрузке страницы, динамически создаваемые формы не подвергаются проверке автоматически. Необходимо указать, что скрипт ненавязчивой проверки jQuery должен анализировать динамическую форму сразу после ее создания. Например, приведенный ниже код показывает, как можно настроить проверку на стороне клиента для формы, добавленной посредством AJAX.

```js
$.get({
    url: "https://url/that/returns/a/form",
    dataType: "html",
    error: function(jqXHR, textStatus, errorThrown) {
        alert(textStatus + ": Couldn't add form. " + errorThrown);
    },
    success: function(newFormHTML) {
        var container = document.getElementById("form-container");
        container.insertAdjacentHTML("beforeend", newFormHTML);
        var forms = container.getElementsByTagName("form");
        var newForm = forms[forms.length - 1];
        $.validator.unobtrusive.parse(newForm);
    }
})
```

Метод `$.validator.unobtrusive.parse()` принимает селектор jQuery в качестве единственного аргумента. Этот метод предписывает скрипту ненавязчивой проверки jQuery анализировать атрибуты `data-` форм в этом селекторе. Значения этих атрибутов затем передаются в подключаемый модуль jQuery Validate для применения к форме требуемых правил проверки на стороне клиента.

### <a name="add-validation-to-dynamic-controls"></a>Добавление проверки к динамическим элементам управления

Вы также можете обновлять правила проверки для формы при динамическом создании отдельных элементов управления, таких как `<input/>` и `<select/>`. Селекторы для этих элементов нельзя передавать в метод `parse()` напрямую, так как содержащая форма уже проанализирована и не обновится. Вместо этого нужно сначала удалить имеющиеся данные проверки, а затем повторно проанализировать всю форму, как показано ниже.

```js
$.get({
    url: "https://url/that/returns/a/control",
    dataType: "html",
    error: function(jqXHR, textStatus, errorThrown) {
        alert(textStatus + ": Couldn't add control. " + errorThrown);
    },
    success: function(newInputHTML) {
        var form = document.getElementById("my-form");
        form.insertAdjacentHTML("beforeend", newInputHTML);
        $(form).removeData("validator")    // Added by jQuery Validate
               .removeData("unobtrusiveValidation");   // Added by jQuery Unobtrusive Validation
        $.validator.unobtrusive.parse(form);
    }
})
```

## <a name="iclientmodelvalidator"></a>IClientModelValidator

Вы можете создать логику на стороне клиента для пользовательского атрибута, и скрипт [ненавязчивой проверки](http://bradwilson.typepad.com/blog/2010/10/mvc3-unobtrusive-validation.html), который создает адаптер для [проверки jquery](http://jqueryvalidation.org/documentation/), будет автоматически выполнять ее в клиенте в рамках проверки. Сначала нужно определить добавляемые атрибуты data-, реализовав интерфейс `IClientModelValidator`, как показано ниже.

[!code-csharp[](validation/sample/ClassicMovieAttribute.cs?range=30-42)]

Атрибуты, реализующие этот интерфейс, могут добавлять атрибуты HTML в создаваемые поля. Если изучить выходные данные элемента `ReleaseDate`, то можно обнаружить код HTML, очень похожий на код из предыдущего примера, за тем исключением, что теперь есть атрибут `data-val-classicmovie`, который был определен в методе `AddValidation` интерфейса `IClientModelValidator`.

```html
<input class="form-control" type="datetime"
    data-val="true"
    data-val-classicmovie="Classic movies must have a release year earlier than 1960."
    data-val-classicmovie-year="1960"
    data-val-required="The ReleaseDate field is required."
    id="ReleaseDate" name="ReleaseDate" value="" />
```

При ненавязчивой проверке данные из атрибутов `data-` используются для вывода сообщений об ошибках. Однако правила или сообщения неизвестны jQuery, пока вы не добавите их в объект `validator` jQuery. Это демонстрируется в приведенном ниже примере, в котором в объект `validator` jQuery добавляется метод с именем `classicmovie`, содержащий пользовательский код проверки на стороне клиента. Метод unobtrusive.adapters.add объясняется [здесь](http://bradwilson.typepad.com/blog/2010/10/mvc3-unobtrusive-validation.html)

[!code-javascript[](validation/sample/Views/Movies/Create.cshtml?range=71-93)]

Теперь в jQuery есть сведения для выполнения пользовательской проверки JavaScript, а также сообщение об ошибке, которое должно выводиться, если код проверки возвращает значение false.

## <a name="remote-validation"></a>Удаленная проверка

Удаленная проверка — это отличная возможность для тех случаев, когда необходимо проверить данные в клиенте, сравнив их с данными на сервере. Например, приложению может потребоваться проверить, используется ли уже адрес электронной почты или имя пользователя, для чего ему необходимо запросить большой объем данных. Скачивание больших наборов данных для проверки одного или нескольких полей приводит к чрезмерному потреблению ресурсов. При этом также возможен несанкционированный доступ к конфиденциальной информации. Альтернативной является запрос приема-передачи для проверки поля.

Удаленную проверку можно реализовать в два этапа. Сначала необходимо аннотировать модель атрибутом `[Remote]`. Атрибут `[Remote]` принимает множество перегрузок, с помощью которых можно указывать вызываемый код в коде JavaScript на стороне клиента. В приведенном ниже примере указывается метод действия `VerifyEmail` контроллера `Users`.

[!code-csharp[](validation/sample/User.cs?range=7-8)]

На втором этапе код проверки помещается в соответствующий метод действия, определенный в атрибуте `[Remote]`. Согласно документации по методу [`remote()`](https://jqueryvalidation.org/remote-method/) jQuery Validate:

> Ответ на стороне сервера должен представлять собой строку в формате JSON, которая должна быть `"true"` для допустимых элементов и может быть `"false"`, `undefined` или `null` для недопустимых элементов, причем используется сообщение об ошибке по умолчанию. Если ответ на стороне сервера является строкой, например `"That name is already taken, try peter123 instead"`, эта строка будет выводиться в качестве пользовательского сообщения об ошибке вместо сообщения по умолчанию.

Определение метода `VerifyEmail()` следует этим правилам, как показано ниже. Метод возвращает сообщение об ошибке проверки, если адрес электронной почты занят, или `true`, если он свободен, заключая результат в объект `JsonResult`. Клиент может затем использовать возвращенное значение для продолжения работы или вывода сообщения об ошибке, если это необходимо.

[!code-csharp[](validation/sample/UsersController.cs?range=19-28)]

Теперь, когда пользователь вводит адрес электронной почты, код JavaScript в представлении совершает удаленный вызов, чтобы проверить, занят ли этот адрес. Если да, выводится сообщение об ошибке. В противном случае пользователь может отправить форму обычным образом.

Свойство `AdditionalFields` атрибута `[Remote]` полезно для проверки сочетаний полей с данными на сервере. Например, если бы в представленной выше модели `User` было бы два дополнительных свойства `FirstName` и `LastName`, могла бы возникнуть необходимость проверить, нет ли уже пользователя с такой парой имен. Новые свойства определяются так, как показано ниже.

[!code-csharp[](validation/sample/User.cs?range=10-13)]

Свойству `AdditionalFields` можно было бы явным образом присвоить строки `"FirstName"` и `"LastName"`, однако применение оператора [`nameof`](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/nameof) упрощает дальнейший рефакторинг. Метод действия, выполняющий проверку, должен в этом случае принимать два аргумента: один для значения `FirstName`, а другой для значения `LastName`.

[!code-csharp[](validation/sample/UsersController.cs?range=30-39)]

Теперь, когда пользователь вводит имя и фамилию, JavaScript выполняет указанные ниже действия.

* Совершает удаленный вызов, чтобы проверить, не занята ли эта пара имен.
* Если пара занята, выводится сообщение об ошибке. 
* Если не занята, пользователь может отправить форму.

Если нужно проверить два или несколько дополнительных полей с помощью атрибута `[Remote]`, их следует указывать в виде списка с разделителями-запятыми. Например, чтобы добавить в модель свойство `MiddleName`, задайте атрибут `[Remote]`, как показано в следующем примере кода:

```cs
[Remote(action: "VerifyName", controller: "Users", AdditionalFields = nameof(FirstName) + "," + nameof(LastName))]
public string MiddleName { get; set; }
```

`AdditionalFields`, как и все аргументы атрибутов, должен представлять собой константное выражение. Поэтому нельзя использовать [интерполированную строку](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/interpolated-strings) или вызов [`string.Join()`](https://msdn.microsoft.com/library/system.string.join(v=vs.110).aspx) для инициализации `AdditionalFields`. Для каждого дополнительного поля, добавляемого в атрибут `[Remote]`, необходимо добавить еще один аргумент в соответствующий метод действия контроллера.
