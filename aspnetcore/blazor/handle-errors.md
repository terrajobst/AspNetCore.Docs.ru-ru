---
title: Обработку ошибок в ASP.NET Core Блазор Apps
author: guardrex
description: Узнайте, как ASP.NET Core Блазор, как Блазор управляет необработанными исключениями и как разрабатывать приложения, которые обнаруживают и обрабатывают ошибки.
monikerRange: '>= aspnetcore-3.0'
ms.author: riande
ms.custom: mvc
ms.date: 10/31/2019
uid: blazor/handle-errors
ms.openlocfilehash: afcaa4d926c3e5f0a018897ce4b67b54574dae77
ms.sourcegitcommit: 77c8be22d5e88dd710f42c739748869f198865dd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/01/2019
ms.locfileid: "73426992"
---
# <a name="handle-errors-in-aspnet-core-blazor-apps"></a>Обработку ошибок в ASP.NET Core Блазор Apps

Автор: [Стив Сандерсон](https://github.com/SteveSandersonMS) (Steve Sanderson)

В этой статье описывается, как Блазор управляет необработанными исключениями и разрабатывает приложения, которые обнаруживают и обрабатывают ошибки.

## <a name="how-the-blazor-framework-reacts-to-unhandled-exceptions"></a>Как платформа Блазор реагирует на необработанные исключения

Блазор Server — это платформа с отслеживанием состояния. Хотя пользователи взаимодействуют с приложением, они сохраняют подключение к серверу, известному как *канал*. Канал содержит экземпляры активных компонентов, а также многие другие аспекты состояния, например:

* Последние отображаемые выходные данные компонентов.
* Текущий набор делегатов обработки событий, которые могут вызываться событиями на стороне клиента.

Если пользователь открывает приложение на нескольких вкладках браузера, у него есть несколько независимых цепей.

Блазор обрабатывает большинство необработанных исключений как неустранимые для канала, где они происходят. Если канал завершается из-за необработанного исключения, пользователь может продолжить взаимодействие с приложением только путем перезагрузки страницы для создания нового канала. Цепи за пределами того, что прерывается, являются цепями для других пользователей или других вкладок браузера, не затрагиваются. Этот сценарий аналогичен классу для настольных приложений, который аварийно завершает работу&mdash;сбой приложения должен быть перезапущен, но другие приложения не затрагиваются.

Цепь завершается, когда необработанное исключение возникает по следующим причинам:

* Необработанное исключение часто оставляет цепь в неопределенном состоянии.
* Нормальная работа приложения не может быть гарантирована после необработанного исключения.
* В случае продолжения канала в приложении могут появиться уязвимости системы безопасности.

## <a name="manage-unhandled-exceptions-in-developer-code"></a>Управление необработанными исключениями в коде разработчика

Чтобы продолжить работу приложения после возникновения ошибки, приложение должно иметь логику обработки ошибок. В последующих разделах этой статьи описываются потенциальные источники необработанных исключений.

В рабочей среде не следует отображать сообщения об исключениях инфраструктуры или трассировки стека в пользовательском интерфейсе. Отрисовка сообщений об исключениях или трассировок стека может:

* Раскрывать конфиденциальные сведения конечным пользователям.
* Помогите злонамеренному пользователю обнаружить слабые места в приложении, которое может нарушить безопасность приложения, сервера или сети.

## <a name="log-errors-with-a-persistent-provider"></a>Регистрация ошибок с помощью постоянного поставщика

При возникновении необработанного исключения исключение заносится в журнал <xref:Microsoft.Extensions.Logging.ILogger> экземпляров, настроенных в контейнере службы. По умолчанию приложения Блазор записывает выходные данные в консоль с помощью поставщика ведения журнала консоли. Рассмотрите возможность входа в более постоянное расположение с поставщиком, который управляет размером журнала и поворотом журнала. Для получения дополнительной информации см. <xref:fundamentals/logging/index>.

Во время разработки Блазор обычно отправляет полные сведения об исключениях в консоль браузера для облегчения отладки. В рабочей среде подробные ошибки в консоли браузера по умолчанию отключены, что означает, что ошибки не отправляются клиентам, но все сведения об исключении все еще регистрируются на стороне сервера. Для получения дополнительной информации см. <xref:fundamentals/error-handling>.

Необходимо решить, какие инциденты следует заносить в журнал, и уровень серьезности регистрируемых инцидентов. Злонамеренные пользователи могут попытаться вызывать ошибки намеренно. Например, не заносить инцидент в журнал из ошибки, если в URL-адресе компонента, отображающего сведения о продукте, указан неизвестный `ProductId`. Не все ошибки следует рассматривать как инциденты высокой серьезности для ведения журнала.

## <a name="places-where-errors-may-occur"></a>Места, где могут возникнуть ошибки

Код платформы и приложения может вызывать необработанные исключения в любом из следующих расположений:

* [Создание экземпляра компонента](#component-instantiation)
* [Методы жизненного цикла](#lifecycle-methods)
* [Логика отрисовки](#rendering-logic)
* [Обработчики событий](#event-handlers)
* [Реализация компонента](#component-disposal)
* [Взаимодействие JavaScript](#javascript-interop)
* [Обработчики цепи](#circuit-handlers)
* [Реализация цепи](#circuit-disposal)
* [Предварительная подготовка](#prerendering)

Предыдущие необработанные исключения описаны в следующих разделах этой статьи.

### <a name="component-instantiation"></a>Создание экземпляра компонента

Когда Блазор создает экземпляр компонента:

* Вызывается конструктор компонента.
* Вызываются конструкторы любых служб одноэлементного внедрения, предоставляемых конструктору компонента через директиву [@inject](xref:blazor/dependency-injection#request-a-service-in-a-component) или атрибут [[Вставка]](xref:blazor/dependency-injection#request-a-service-in-a-component) . 

Сбой канала, когда любой выполненный конструктор или метод задания для любого `[Inject]`ного свойства вызывает необработанное исключение. Исключение является неустранимым, так как платформе не удается создать экземпляр компонента. Если логика конструктора может вызывать исключения, приложение должно выполнить перехват исключений с помощью оператора [try-catch](/dotnet/csharp/language-reference/keywords/try-catch) с обработкой ошибок и ведением журнала.

### <a name="lifecycle-methods"></a>Методы жизненного цикла

В течение времени существования компонента Блазор вызывает методы жизненного цикла:

* `OnInitialized` / `OnInitializedAsync`
* `OnParametersSet` / `OnParametersSetAsync`
* `ShouldRender` / `ShouldRenderAsync`
* `OnAfterRender` / `OnAfterRenderAsync`

Если какой-либо метод жизненного цикла вызывает исключение синхронно или асинхронно, исключение является неустранимым для канала. Для компонентов, обрабатывающих ошибки в методах жизненного цикла, добавьте логику обработки ошибок.

В следующем примере `OnParametersSetAsync` вызывает метод для получения продукта:

* Исключение, вызванное в методе `ProductRepository.GetProductByIdAsync`, обрабатывается оператором `try-catch`.
* При выполнении блока `catch`:
  * `loadFailed` имеет значение `true`, которое используется для вывода сообщения об ошибке пользователю.
  * Ошибка заносится в журнал.

[!code-cshtml[](handle-errors/samples_snapshot/3.x/product-details.razor?highlight=11,27-39)]

### <a name="rendering-logic"></a>Логика отрисовки

Декларативная разметка в файле компонента `.razor` компилируется в метод C# с именем `BuildRenderTree`. Когда компонент подготавливается к просмотру, `BuildRenderTree` выполняет и создает структуру данных, описывающую элементы, текст и дочерние компоненты отображаемого компонента.

Логика отрисовки может вызывать исключение. Пример этого сценария происходит, когда `@someObject.PropertyName` вычисляется, но `@someObject` `null`. Необработанное исключение, созданное логикой отрисовки, является неустранимым для канала.

Чтобы предотвратить исключение пустой ссылки в логике отрисовки, проверьте объект `null` перед доступом к его членам. В следующем примере свойства `person.Address` недоступны, если `person.Address` `null`:

[!code-cshtml[](handle-errors/samples_snapshot/3.x/person-example.razor?highlight=1)]

В приведенном выше коде предполагается, что `person` не `null`. Часто структура кода гарантирует, что объект существует на момент подготовки компонента к просмотру. В таких случаях нет необходимости проверять наличие `null` в логике отрисовки. В предыдущем примере `person` может быть гарантированно существовать, поскольку `person` создается при создании экземпляра компонента.

### <a name="event-handlers"></a>Обработчики событий

Код на стороне клиента активирует вызовы C# кода при создании обработчиков событий с помощью:

* `@onclick`
* `@onchange`
* Другие атрибуты `@on...`
* `@bind`

В этих сценариях код обработчика событий может вызывать необработанное исключение.

Если обработчик событий создает необработанное исключение (например, запрос к базе данных завершается ошибкой), исключение является неустранимым для канала. Если приложение вызывает код, который может завершиться ошибкой по внешним причинам, необходимо выполнить перехват исключений с помощью оператора [try-catch](/dotnet/csharp/language-reference/keywords/try-catch) с обработкой ошибок и ведением журнала.

Если пользовательский код не выполняет перехват и обработку исключения, платформа регистрирует исключение и завершает цепь.

### <a name="component-disposal"></a>Реализация компонента

Компонент может быть удален из пользовательского интерфейса, например, потому, что пользователь перешел на другую страницу. Когда компонент, реализующий <xref:System.IDisposable?displayProperty=fullName>, удаляется из пользовательского интерфейса, платформа вызывает метод <xref:System.IDisposable.Dispose*> компонента. 

Если метод `Dispose` компонента создает необработанное исключение, исключение является неустранимым для канала. Если логика реализации может вызывать исключения, приложение должно выполнить перехват исключений с помощью оператора [try-catch](/dotnet/csharp/language-reference/keywords/try-catch) с обработкой ошибок и ведением журнала.

Дополнительные сведения об утилизации компонентов см. в разделе <xref:blazor/components#component-disposal-with-idisposable>.

### <a name="javascript-interop"></a>Взаимодействие с JavaScript

`IJSRuntime.InvokeAsync<T>` позволяет коду .NET выполнять асинхронные вызовы среды выполнения JavaScript в браузере пользователя.

При обработке ошибок с помощью `InvokeAsync<T>`применяются следующие условия.

* Если вызов `InvokeAsync<T>` выполняется синхронно, возникает исключение .NET. Вызов `InvokeAsync<T>` может завершиться ошибкой, например, поскольку передаваемые аргументы не могут быть сериализованы. Код разработчика должен перехватить исключение. Если код приложения в обработчике событий или в методе жизненного цикла компонента не обрабатывает исключение, полученное исключение является неустранимым для канала.
* Если вызов `InvokeAsync<T>` асинхронно завершается сбоем, <xref:System.Threading.Tasks.Task> .NET завершается ошибкой. Вызов `InvokeAsync<T>` может завершиться ошибкой, например, так как код на стороне JavaScript вызывает исключение или возвращает `Promise`, который был завершен как `rejected`. Код разработчика должен перехватить исключение. При использовании оператора [await](/dotnet/csharp/language-reference/keywords/await) рекомендуется обернуть вызов метода в инструкцию [try-catch](/dotnet/csharp/language-reference/keywords/try-catch) с обработкой ошибок и ведением журнала. В противном случае сбой кода приводит к возникновению необработанного исключения, которое является неустранимым для канала.
* По умолчанию вызовы `InvokeAsync<T>` должны завершаться в течение определенной точки или в другом случае истекает время ожидания вызова. По умолчанию используется период ожидания в одну минуту. Время ожидания защищает код от потери сетевого подключения или кода JavaScript, который никогда не отправляет обратно сообщение о завершении. Если время ожидания вызова истекает, полученный `Task` завершается с <xref:System.OperationCanceledException>. Ловушка и обработка исключения с ведением журнала.

Аналогичным образом код JavaScript может инициировать вызовы методов .NET, указанных [атрибутом [жсинвокабле]](xref:blazor/javascript-interop#invoke-net-methods-from-javascript-functions). Если эти методы .NET создают необработанное исключение:

* Исключение не рассматривается как неустранимое для канала.
* `Promise` на стороне JavaScript отклоняется.

Вы можете использовать код обработки ошибок либо на стороне .NET, либо на стороне JavaScript вызова метода.

Для получения дополнительной информации см. <xref:blazor/javascript-interop>.

### <a name="circuit-handlers"></a>Обработчики цепи

Блазор позволяет коду определять *обработчик цепи*, который получает уведомления при изменении состояния канала пользователя. Используются следующие состояния:

* `initialized`
* `connected`
* `disconnected`
* `disposed`

Управление уведомлениями осуществляется путем регистрации службы DI, которая наследуется от абстрактного базового класса `CircuitHandler`.

Если методы пользовательского обработчика цепи создают необработанное исключение, исключение является неустранимым для канала. Чтобы допускать исключения в коде обработчика или вызывать методы, заключите код в один или несколько инструкций [try-catch](/dotnet/csharp/language-reference/keywords/try-catch) с обработкой ошибок и ведением журнала.

### <a name="circuit-disposal"></a>Реализация цепи

Когда цепь завершается из-за того, что пользователь отключился и платформа очищает состояние канала, платформа удаляет область DI цепи. Удаление области удаляет все службы DI с областью действия цепи, реализующие <xref:System.IDisposable?displayProperty=fullName>. Если любая служба DI вызывает необработанное исключение во время удаления, платформа регистрирует исключение.

### <a name="prerendering"></a>Предварительная подготовка

Компоненты блазор можно предварительно подготовить с помощью `Html.RenderComponentAsync`, чтобы их визуализированная HTML-разметка возвращалась как часть исходного HTTP-запроса пользователя. Это работает следующим образом.

* Создание нового канала для всех предварительно отображенных компонентов, которые являются частью одной страницы.
* Создание исходного HTML-кода.
* Рассматривая канал как `disconnected` до тех пор, пока браузер пользователя не установит подключение SignalR к тому же серверу. Если соединение установлено, взаимодействие с каналом возобновляется, а HTML-разметка компонентов обновляется.

Если какой-либо компонент создает необработанное исключение во время предварительной отрисовки, например во время метода жизненного цикла или в логике отрисовки:

* Исключение является неустранимым для канала.
* Исключение вызывается стеком вызовов из вызова `Html.RenderComponentAsync`. Таким образом, весь HTTP-запрос завершается ошибкой, если только исключение явно не перехвачено кодом разработчика.

В нормальных обстоятельствах при сбое предварительной визуализации продолжение сборки и визуализации компонента не имеет смысла, так как не удается подготовить рабочий компонент к просмотру.

Чтобы допускать ошибки, которые могут возникнуть во время предварительной подготовки, логика обработки ошибок должна размещаться внутри компонента, который может вызывать исключения. Используйте операторы [try-catch](/dotnet/csharp/language-reference/keywords/try-catch) с обработкой ошибок и ведением журнала. Вместо заключения в оболочку вызова `RenderComponentAsync` в инструкции `try-catch` разместите логику обработки ошибок в компоненте, отображаемом `RenderComponentAsync`.

## <a name="advanced-scenarios"></a>Расширенные сценарии

### <a name="recursive-rendering"></a>Рекурсивная визуализация

Компоненты могут быть вложенными рекурсивно. Это полезно для представления рекурсивных структур данных. Например, компонент `TreeNode` может отображать больше `TreeNode` компонентов для каждого из дочерних узлов узла.

При рекурсивной отрисовке Избегайте шаблонов программирования, которые приводят к бесконечной рекурсии:

* Не следует рекурсивно подготавливать структуру данных, содержащую цикл. Например, не следует визуализировать узел дерева, дочерние элементы которого содержат сам себя.
* Не создавайте цепочку макетов, содержащих цикл. Например, не создавайте макет, макет которого сам является.
* Не разрешайте пользователю нарушать инварианты рекурсии (правила) с помощью ввода вредоносных данных или вызовов взаимодействия JavaScript.

Бесконечные циклы во время подготовки к просмотру:

* Приводит к тому, что процесс подготовки к просмотру будет выполняться бессрочно.
* Эквивалентно созданию незавершенного цикла.

В этих сценариях происходит зависание цепи, и поток обычно пытается выполнить следующие действия.

* Потребляет столько процессорных ресурсов, сколько разрешено операционной системой, неопределенное время.
* Использование неограниченного объема памяти сервера. Использование неограниченного объема памяти эквивалентно сценарию, в котором незавершенный цикл добавляет записи в коллекцию при каждой итерации.

Чтобы избежать бесконечного шаблона рекурсии, убедитесь, что рекурсивный код отрисовки содержит подходящие условия остановки.

### <a name="custom-render-tree-logic"></a>Логика пользовательского дерева отрисовки

Большинство компонентов Блазор реализуются как файлы *Razor* и компилируются для создания логики, которая работает с `RenderTreeBuilder` для отрисовки выходных данных. Разработчик может вручную реализовать логику `RenderTreeBuilder` с помощью C# процедурного кода. Для получения дополнительной информации см. <xref:blazor/components#manual-rendertreebuilder-logic>.

> [!WARNING]
> Использование логики построителя дерева ручного просмотра считается расширенным и небезопасным сценарием, не рекомендуемым для разработки общих компонентов.

При написании кода `RenderTreeBuilder` разработчик должен гарантировать правильность кода. Например, разработчик должен убедиться в том, что:

* Вызовы `OpenElement` и `CloseElement` правильно сбалансированы.
* Атрибуты добавляются только в нужные места.

Неправильная логика конструктора ручного отображения дерева может вызвать произвольное неопределенное поведение, включая сбои, зависания сервера и уязвимости системы безопасности.

Рассматривайте логику построителя дерева вручную на том же уровне сложности и с тем же уровнем *опасности* , что и при написании кода сборки или инструкций MSIL вручную.
