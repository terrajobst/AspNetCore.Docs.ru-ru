---
title: Безопасные ASP.NET Core серверные приложения Блазор
author: guardrex
description: Узнайте, как устранить угрозы безопасности для Блазор серверных приложений.
monikerRange: '>= aspnetcore-3.0'
ms.author: riande
ms.custom: mvc
ms.date: 09/07/2019
uid: security/blazor/server
ms.openlocfilehash: 72788980ff7c7bd56f55e4e84d820a3684f7275e
ms.sourcegitcommit: 092061c4f6ef46ed2165fa84de6273d3786fb97e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/13/2019
ms.locfileid: "70964242"
---
# <a name="secure-aspnet-core-blazor-server-apps"></a>Безопасные ASP.NET Core серверные приложения Блазор

[Хавьер Калварро Воронков](https://github.com/javiercn)

Серверные приложения блазор принимают модель обработки данных с *отслеживанием состояния* , где сервер и клиент поддерживают долгосрочную связь. Постоянное состояние поддерживается [каналом](xref:blazor/state-management), который может охватывать соединения, которые также потенциально долго исключаются.

Когда пользователь посещает сайт Блазор Server, сервер создает канал в памяти сервера. Канал указывает браузеру, какое содержимое подготавливается к просмотру, и реагирует на события, например, когда пользователь выбирает кнопку в пользовательском интерфейсе. Для выполнения этих действий цепь вызывает функции JavaScript в браузере пользователя и методах .NET на сервере. Это двустороннее взаимодействие на основе JavaScript называется взаимодействием [JavaScript (JS Interop)](xref:blazor/javascript-interop).

Поскольку взаимодействие с JS происходит через Интернет, а клиент использует удаленный браузер, Блазор Server Apps предоставляет большинство проблем безопасности веб-приложений. В этом разделе описываются распространенные угрозы для Блазор серверных приложений и предоставляются рекомендации по предотвращению угроз, направленные на приложения с выходом в Интернет.

В ограниченных средах, например в корпоративных сетях или интрасетях, некоторые рекомендации по устранению рисков:

* Не применяется в ограниченной среде.
* Не стоит тратить затраты на реализацию, так как в ограниченной среде существует угроза безопасности.

## <a name="resource-exhaustion"></a>Нехватка ресурсов

Нехватка ресурсов может произойти, когда клиент взаимодействует с сервером и заставляет сервер потреблять чрезмерные ресурсы. Чрезмерное потребление ресурсов в основном влияет на:

* [CPU](#cpu)
* [Память](#memory)
* [Клиентские подключения](#client-connections)

Атаки типа "отказ в обслуживании" (DoS) обычно ищут исчерпание ресурсов приложения или сервера. Однако нехватка ресурсов не обязательно является результатом атаки на систему. Например, ограниченные ресурсы могут быть исчерпаны из-за высокой потребности пользователей. DoS рассматривается в разделе [атаки типа "отказ в обслуживании" (DOS)](#denial-of-service-dos-attacks) .

Ресурсы, внешние по отношению к Блазор Framework, такие как базы данных и дескрипторы файлов (используемые для чтения и записи файлов), могут также испытывать нехватку ресурсов. Дополнительные сведения см. в разделе <xref:performance/performance-best-practices>.

### <a name="cpu"></a>ЦП

Нехватка ресурсов ЦП может возникать, когда один или несколько клиентов вынуждены заставить сервер выполнять интенсивную работу ЦП.

Например, рассмотрим серверное приложение Блазор, которое вычисляет *фибоннакЦи число*. Номер ФибоннакЦи создается из последовательности ФибоннакЦи, где каждое число в последовательности является суммой двух предыдущих чисел. Объем работы, необходимый для достижения ответа, зависит от длины последовательности и размера начального значения. Если приложение не помещает ограничения на клиентский запрос, вычисления с интенсивным использованием ЦП могут повлиять на время ЦП и уменьшить производительность других задач. Чрезмерное потребление ресурсов является проблемой безопасности, влияющей на доступность.

Нехватка ресурсов ЦП очень важна для всех общедоступных приложений. В обычных веб-приложениях время ожидания запросов и соединений является защитой, но Блазор серверные приложения не обеспечивают одинаковые меры безопасности. Серверные приложения блазор должны включать соответствующие проверки и ограничения перед выполнением потенциально требовательных к ЦП операций.

### <a name="memory"></a>Память

Нехватка памяти может произойти, когда один или несколько клиентов вынуждены принудительно использовать большой объем памяти.

Например, рассмотрим Блазор приложение на стороне сервера с компонентом, который принимает и отображает список элементов. Если приложение Блазор не устанавливает ограничения на количество разрешенных элементов или число элементов, отображаемых обратно клиенту, обработка и отрисовка с интенсивным использованием памяти может полагаться на то, что производительность сервера снижается. Сервер может аварийно завершить работу или замедляться до момента сбоя.

Рассмотрим следующий сценарий для обслуживания и отображения списка элементов, относящихся к потенциальному сценарию нехватки памяти на сервере:

* Элементы в `List<MyItem>` свойстве или поле используют память сервера. Если приложение разрешает неограниченный рост списка элементов, существует риск нехватки памяти на сервере. При нехватке памяти текущий сеанс завершается (со сбоем) и все параллельные сеансы в этом экземпляре сервера получают исключение нехватки памяти. Чтобы предотвратить возникновение этого сценария, приложение должно использовать структуру данных, которая накладывает ограничение на число элементов для параллельных пользователей.
* Если схема подкачки не используется для отрисовки, сервер использует дополнительную память для объектов, которые не видны в пользовательском интерфейсе. Без ограничения на количество элементов требования к памяти могут привести к исчерпанию доступной памяти сервера. Чтобы предотвратить такой сценарий, используйте один из следующих подходов:
  * Используйте списки с разбивкой на страницы при подготовке к просмотру.
  * Отображать только первые 100 – 1 000 элементов и требовать от пользователя ввести условия поиска для поиска элементов за пределами отображаемых элементов.
  * Для более расширенного сценария подготовки к просмотру реализуйте списки или сетки, поддерживающие *виртуализацию*. С помощью виртуализации в списках отображаются только подмножество элементов, видимых пользователю. Когда пользователь взаимодействует с полосой прокрутки в пользовательском интерфейсе, компонент отображает только те элементы, которые требуются для отображения. Элементы, которые в данный момент не требуются для вывода, могут храниться во вторичном хранилище, что является идеальным подходом. Неотображаемые элементы также могут храниться в памяти, что является менее идеальным.

Серверные приложения блазор предлагают аналогичную модель программирования для других платформ пользовательского интерфейса для приложений с отслеживанием состояния, таких как WPF, Windows Forms или Блазор. Основное отличие состоит в том, что в некоторых платформах пользовательского интерфейса объем памяти, потребляемой приложением, принадлежит клиенту и влияет только на этот клиент. Например, приложение Блазор на стороне клиента полностью работает на клиенте и использует только ресурсы памяти клиента. В сценарии сервера Блазор память, потребляемая приложением, принадлежит серверу и является общей для клиентов на экземпляре сервера.

Требования к памяти на стороне сервера учитываются для всех серверных приложений Блазор. Однако большинство веб-приложений не имеют состояния, и память, используемая при обработке запроса, освобождается при возврате ответа. В качестве общей рекомендации не разрешите клиентам выделять неограниченный объем памяти, как в любом другом серверном приложении, сохраняющем клиентские подключения. Объем памяти, потребляемой приложением Блазор Server, сохраняется дольше одного запроса.

> [!NOTE]
> Во время разработки можно использовать профилировщик или трассировку, отслеживаемую для оценки требований к памяти клиентов. Профилировщик или трассировка не захватывает память, выделенную для конкретного клиента. Чтобы записать использование памяти конкретным клиентом во время разработки, запишите дамп и изучите потребность в памяти для всех объектов, имеющих корень в цепи пользователя.

### <a name="client-connections"></a>Клиентские подключения

Нехватка подключений может возникать, когда один или несколько клиентов открывают слишком много одновременных подключений к серверу, предотвращая установку новых подключений другими клиентами.

Клиенты блазор устанавливают одно подключение для каждого сеанса и сохраняют соединение в открытом окне, пока открыто окно браузера. Требования к серверу для обслуживания всех подключений не относятся к приложениям Блазор. Учитывая постоянную природу подключений и характерность Блазор серверных приложений, нехватка подключений повышает риск доступности приложения.

По умолчанию количество подключений на одного пользователя для серверного приложения Блазор не ограничено. Если для приложения требуется ограничение числа подключений, воспользуйтесь одним или несколькими из следующих подходов.

* Требовать проверку подлинности, которая естественным образом ограничивает возможность неавторизованных пользователей подключаться к приложению. Чтобы этот сценарий действовал, пользователи должны быть предотвращены от подготовки новых пользователей.
* Ограничьте число подключений на пользователя. Ограничение подключений можно выполнить с помощью следующих подходов. Примите во внимание, чтобы предоставить законным пользователям доступ к приложению (например, если установлено ограничение на число подключений на основе IP-адреса клиента).
  * На уровне приложения:
    * Расширяемость маршрутизации конечных точек.
    * Требовать проверку подлинности для подключения к приложению и наблюдения за активными сеансами на пользователя.
    * Отклоните новые сеансы при достижении предела.
    * Прокси-подключения WebSocket к приложению с помощью прокси-сервера, например [службы SignalR Azure](/azure/azure-signalr/signalr-overview) , которые мультиплексированы подключения от клиентов к приложению. Это предоставляет приложению более высокую емкость подключения, чем может установить один клиент, что предотвращает исчерпание подключений клиента к серверу.
  * На уровне сервера: Используйте прокси-сервер или шлюз перед приложением. Например, [Передняя дверца Azure](/azure/frontdoor/front-door-overview) позволяет определять и отслеживать глобальную маршрутизацию веб-трафика в приложение, а также управлять им.

## <a name="denial-of-service-dos-attacks"></a>Атаки типа "отказ в обслуживании" (DoS)

Атаки типа "отказ в обслуживании" (DoS) подразумевают, что клиент выводит на сервер недоступность одного или нескольких ресурсов из-за того, что приложение не будет доступно. Серверные приложения блазор включают некоторые ограничения по умолчанию и полагаются на другие ASP.NET Core и ограничения SignalR для защиты от атак DoS.

| Ограничение серверного приложения блазор                            | Описание | Значение по умолчанию |
| ------------------------------------------------------- | ----------- | ------- |
| `CircuitOptions.DisconnectedCircuitMaxRetained`         | Максимальное число отключенных каналов, которые заданный сервер удерживает в памяти за один раз. | 100 |
| `CircuitOptions.DisconnectedCircuitRetentionPeriod`     | Максимальное время, в течение которого отключенная цепь удерживается в памяти, прежде чем будет прервана. | 3 минуты |
| `CircuitOptions.JSInteropDefaultCallTimeout`            | Максимальное время ожидания сервера до истечения времени ожидания асинхронного вызова функции JavaScript. | 1 минута |
| `CircuitOptions.MaxBufferedUnacknowledgedRenderBatches` | Максимальное число неподтвержденных пакетов рендеринга, которые сервер хранит в памяти на канал в указанное время для поддержки надежного повторного подключения. После достижения предела сервер прекращает создавать новые пакеты рендеринга, пока один или несколько пакетов не будут подтверждены клиентом. | 10 |


| Ограничение SignalR и ASP.NET Core             | Описание | Значение по умолчанию |
| ------------------------------------------ | ----------- | ------- |
| `CircuitOptions.MaximumReceiveMessageSize` | Размер сообщения для отдельного сообщения. | 32 КБ |

## <a name="interactions-with-the-browser-client"></a>Взаимодействие с браузером (клиент)

Клиент взаимодействует с сервером через JS-событие взаимодействия и завершение отрисовки. Взаимодействие между JavaScript и .NET осуществляется в обоих направлениях:

* События браузера отправляются с клиента на сервер асинхронным образом.
* Сервер отвечает асинхронно, при необходимости, перерисовывает пользовательский интерфейс.

### <a name="javascript-functions-invoked-from-net"></a>Функции JavaScript, вызываемые из .NET

Для вызовов из методов .NET к JavaScript:

* Все вызовы имеют настраиваемое время ожидания, по истечении которых они завершаются <xref:System.OperationCanceledException> сбоем, возвращая в вызывающий объект.
  * По умолчанию время ожидания вызовов (`CircuitOptions.JSInteropDefaultCallTimeout`) равно одной минуте. Чтобы настроить это ограничение, см <xref:blazor/javascript-interop#harden-js-interop-calls>. раздел.
  * Для управления отменой на основе каждого вызова можно предоставить токен отмены. Полагаться на время ожидания вызова по умолчанию, когда это возможно, и с ограниченным временем любым вызовом клиента, если предоставлен токен отмены.
* Результат вызова JavaScript не может быть доверенным. Клиент приложения Блазор, запущенный в браузере, выполняет поиск вызываемой функции JavaScript. Вызывается функция и создается либо результат, либо ошибка. Вредоносный клиент может попытаться:
  * Вызывает проблемы в приложении, возвращая ошибку из функции JavaScript.
  * Вызывает непреднамеренное поведение сервера, возвращая непредвиденный результат из функции JavaScript.

Примите следующие меры предосторожности, чтобы защититься от предыдущих сценариев.

* Заключите вызовы взаимодействия JS внутри операторов [try-catch](/dotnet/csharp/language-reference/keywords/try-catch) , чтобы учитывать ошибки, которые могут возникнуть во время вызовов. Дополнительные сведения см. в разделе <xref:blazor/handle-errors#javascript-interop>.
* Перед выполнением каких бы то ни было действий проверьте данные, возвращаемые при вызовах взаимодействия с JS, включая сообщения об ошибках.

### <a name="net-methods-invoked-from-the-browser"></a>Методы .NET, вызываемые из браузера

Не следует доверять вызовам от JavaScript к методам .NET. Когда метод .NET предоставляется JavaScript, рассмотрите способ вызова метода .NET:

* Рассматривайте любой метод .NET, предоставляемый JavaScript, так же, как общедоступная конечная точка приложения.
  * Проверьте входные данные.
    * Убедитесь, что значения находятся в пределах ожидаемых диапазонов.
    * Убедитесь, что у пользователя есть разрешение на выполнение запрошенного действия.
  * Не выделяйте чрезмерное количество ресурсов в рамках вызова метода .NET. Например, выполните проверки и ограничения на использование ЦП и памяти.
  * Примите во внимание, что статический метод и методы экземпляра могут предоставляться клиентам JavaScript. Избегайте совместного использования состояний в сеансах, если только не вызывается конструктор для предоставления общего состояния с соответствующими ограничениями.
    * Для методов экземпляров, предоставляемых через `DotNetReference` объекты, которые изначально были созданы с помощью внедрения зависимостей (DI), объекты должны быть зарегистрированы как объекты с областью действия. Это относится к любой службе DI, используемой приложением сервера Блазор.
    * Для статических методов Избегайте установки состояния, которое не может быть ограничено клиентом, если только приложение явно не предоставляет состояние по-проектированию для всех пользователей на экземпляре сервера.
  * Старайтесь не передавать пользовательские данные в параметрах вызовов JavaScript. Если передача данных в параметрах является абсолютно обязательной, убедитесь, что код JavaScript обрабатывает передачу данных без введения уязвимостей [межсайтовых сценариев (XSS)](#cross-site-scripting-xss) . Например, не записывайте данные, предоставленные пользователем, в модель DOM (DOM), задав `innerHTML` свойство элемента. Рассмотрите возможность использования [политики безопасности содержимого (CSP)](https://developer.mozilla.org/docs/Web/HTTP/CSP) для отключения `eval` и других ненадежных примитивов JavaScript.
* Избегайте реализации пользовательского диспетчеризации вызовов .NET поверх реализации диспетчеризации платформы. Предоставление доступа к методам .NET для браузера является расширенным сценарием, не рекомендуемым для общей Блазор разработки.

### <a name="events"></a>События

События предоставляют точку входа для серверного приложения Блазор. Те же правила защиты конечных точек в веб-приложениях применяются к обработке событий в приложениях Блазор Server. Вредоносный клиент может отправить в качестве полезных данных для события любые данные, которые он хочет отправить.

Например:

* Событие изменения для `<select>` может отправить значение, не находящиеся в параметрах, представленных приложением для клиента.
* `<input>` Может отправить на сервер любые текстовые данные, минуя проверку на стороне клиента.

Приложение должно проверить данные для любого события, обрабатываемого приложением. [Компоненты форм](xref:blazor/forms-validation) блазор Framework выполняют основные проверки. Если приложение использует пользовательские компоненты форм, для проверки правильности данных событий необходимо написать пользовательский код.

События сервера блазор являются асинхронными, поэтому несколько событий можно отправить на сервер, прежде чем приложение сможет реагировать на них, создавая новый рендеринг. Это позволяет учитывать некоторые аспекты безопасности. Ограничение клиентских действий в приложении должно выполняться внутри обработчиков событий и не зависеть от текущего состояния представления, готового к просмотру.

Рассмотрим компонент счетчика, который должен позволить пользователю увеличить счетчик до трех раз. Кнопка для увеличения счетчика зависит от значения `count`:

```cshtml
<p>Count: @count<p>

@if (count < 3)
{
    <button @onclick="IncrementCount" value="Increment count" />
}

@code 
{
    private int count = 0;

    private void IncrementCount()
    {
        count++;
    }
}
```

Клиент может отправить одно или несколько событий приращения, прежде чем платформа создаст новый рендеринг этого компонента. Результат заключается в том, `count` что пользователь может увеличиваться в *три раза* , поскольку кнопка не удаляется в пользовательском интерфейсе достаточно быстро. Правильный способ достижения ограничения в три `count` шага показан в следующем примере:

```cshtml
<p>Count: @count<p>

@if (count < 3)
{
    <button @onclick="IncrementCount" value="Increment count" />
}

@code 
{
    private int count = 0;

    private void IncrementCount()
    {
        if (count < 3)
        {
            count++;
        }
    }
}
```

Если добавить `if (count < 3) { ... }` проверку внутри обработчика, решение приращения `count` будет основано на текущем состоянии приложения. Решение не зависит от состояния пользовательского интерфейса, которое было в предыдущем примере, что может быть временно устаревшим.

### <a name="guard-against-multiple-dispatches"></a>Защита от нескольких отправок

Если обратный вызов события вызывает длительную операцию, например получение данных из внешней службы или базы данных, рекомендуется использовать условие. Это условие может препятствовать постановке пользователем в очередь нескольких операций во время выполнения операции с визуальным отзывом. Следующий код компонента задает `isLoading` значение, чтобы `GetForecastAsync` `true` при получении данных с сервера. Пока `isLoading` имеет `true`значение, кнопка отключена в пользовательском интерфейсе:

```cshtml
@page "/fetchdata"
@using BlazorServerSample.Data
@inject WeatherForecastService ForecastService

<button disabled="@isLoading" @onclick="UpdateForecasts">Update</button>

@code {
    private bool isLoading;
    private WeatherForecast[] forecasts;

    private async Task UpdateForecasts()
    {
        if (!isLoading)
        {
            isLoading = true;
            forecasts = await ForecastService.GetForecastAsync(DateTime.Now);
            isLoading = false;
        }
    }
}
```

### <a name="cancel-early-and-avoid-use-after-dispose"></a>Отмена в начале и избежание использования-After-Dispose

Помимо использования защиты, как описано в разделе [Защита от нескольких исправлений](#guard-against-multiple-dispatches) , рекомендуется использовать <xref:System.Threading.CancellationToken> для отмены длительных операций при удалении компонента. Этот подход обладает дополнительными преимуществами для предотвращения *использования после удаления* в компонентах:

```cshtml
@implements IDisposable

...

@code {
    private readonly CancellationTokenSource TokenSource = 
        new CancellationTokenSource();

    private async Task UpdateForecasts()
    {
        ...

        forecasts = await ForecastService.GetForecastAsync(DateTime.Now, 
            TokenSource.Token);

        if (TokenSource.Token.IsCancellationRequested)
        {
           return;
        }

        ...
    }

    public void Dispose()
    {
        CancellationTokenSource.Cancel();
    }
}
```

### <a name="avoid-events-that-produce-large-amounts-of-data"></a>Избегайте событий, создающих большие объемы данных

Некоторые события DOM, такие как `oninput` или `onscroll`, могут создавать большой объем данных. Избегайте использования этих событий в приложениях Блазор Server.

## <a name="additional-security-guidance"></a>Дополнительные рекомендации по безопасности

Рекомендации по защите ASP.NET Core приложений применяются к серверным приложениям Блазор и рассматриваются в следующих разделах:

* [Ведение журнала и конфиденциальные данные](#logging-and-sensitive-data)
* [Защита информации при передаче с помощью HTTPS](#protect-information-in-transit-with-https)
* [Межсайтовые сценарии (XSS)](#cross-site-scripting-xss)
* [Защита от разных источников](#cross-origin-protection)
* [Щелчок](#click-jacking)
* [Открыть перенаправления](#open-redirects)

### <a name="logging-and-sensitive-data"></a>Ведение журнала и конфиденциальные данные

Взаимодействие взаимодействия между клиентом и сервером осуществляется в журналы сервера с <xref:Microsoft.Extensions.Logging.ILogger> экземплярами. Блазор позволяет избежать записи конфиденциальной информации, например фактических событий или входных и выходных данных взаимодействия JS.

При возникновении ошибки на сервере платформа уведомляет клиента и слезами сеанс. По умолчанию клиент получает общее сообщение об ошибке, которое можно увидеть в средствах разработчика браузера.

Ошибка на стороне клиента не включает стек вызовов и не предоставляет сведений о причине ошибки, но журналы сервера содержат такие сведения. В целях разработки конфиденциальные сведения об ошибках можно сделать доступными для клиента, включив подробные ошибки.

Включить подробные сведения об ошибках с помощью:

* `CircuitOptions.DetailedErrors`.
* `DetailedErrors`ключ конфигурации. Например, задайте `ASPNETCORE_DETAILEDERRORS` для переменной среды `true`значение.

> [!WARNING]
> Предоставление сведений об ошибках клиентам в Интернете является угрозой безопасности, которую всегда следует избегать.

### <a name="protect-information-in-transit-with-https"></a>Защита информации при передаче с помощью HTTPS

Блазор Server использует SignalR для обмена данными между клиентом и сервером. Блазор Server обычно использует транспорт, который согласовывает SignalR, который обычно является WebSocket.

Сервер блазор не гарантирует целостность и конфиденциальность данных, передаваемых между сервером и клиентом. Всегда используйте HTTPS.

### <a name="cross-site-scripting-xss"></a>Межсайтовые сценарии (XSS)

Межсайтовые сценарии (XSS) позволяют неавторизованной стороне выполнять произвольную логику в контексте браузера. Скомпрометированное приложение потенциально может выполнять произвольный код на клиенте. Уязвимость может быть использована для выполнения ряда вредоносных действий на сервере.

* Отправка фиктивных или недопустимых событий на сервер.
* Отработка отказа/недопустимые завершения подготовки к просмотру.
* Избегайте диспетчеризации завершений рендеринга.
* Отправка вызовов взаимодействия из JavaScript в .NET.
* Измените ответ вызовов взаимодействия с .NET на JavaScript.
* Избегайте отправки результатов взаимодействия .NET с JS.

Блазор Server Framework предпринимает меры для защиты от некоторых из предыдущих угроз.

* Прекращает создание новых обновлений пользовательского интерфейса, если клиент не будет подтверждать пакеты отрисовки. Настроено `CircuitOptions.MaxBufferedUnacknowledgedRenderBatches`с помощью.
* Истечение времени ожидания вызова .NET to JavaScript через одну минуту без получения ответа от клиента. Настроено `CircuitOptions.JSInteropDefaultCallTimeout`с помощью.
* Выполняет базовую проверку всех входных данных, поступающих из браузера во время взаимодействия с JS:
  * Ссылки на .NET являются допустимыми и типа, ожидаемого методом .NET.
  * Данные не имеют неправильный формат.
  * В полезных данных содержится правильное число аргументов для метода.
  * Аргументы или результат можно правильно десериализовать перед вызовом метода.
* Выполняет базовую проверку всех входных данных, поступающих от браузера, от отправленных событий:
  * Событие имеет допустимый тип.
  * Данные для события могут быть десериализованы.
  * С событием связан обработчик событий.

В дополнение к средствам защиты, реализуемым платформой, приложение должно быть закодировано разработчиком для защиты от угроз и выполнения соответствующих действий:

* Всегда проверяйте данные при обработке событий.
* Предпринимать необходимые действия при получении недопустимых данных:
  * Пропускать данные и возвращать. Это позволяет приложению продолжить обработку запросов.
  * Если приложение определяет, что входные данные столкновении и не могут быть получены законным клиентом, вызовите исключение. Создание исключения слезами канал вниз и завершает сеанс.
* Не следует доверять сообщению об ошибке, предоставленному в журналах завершения обработки пакетов, включенных в журналы. Эта ошибка предоставляется клиентом и не может быть доверенной, так как клиент может быть скомпрометирован.
* Не следует доверять входным вызовам взаимодействия на JS в любом направлении между методами JavaScript и .NET.
* Приложение отвечает за проверку допустимости содержимого аргументов и результатов, даже если аргументы или результаты правильно десериализованы.

Чтобы уязвимость XSS существовала, приложение должно включить пользовательский ввод на странице, подготовленной для просмотра. Серверные компоненты блазор выполняют шаг времени компиляции, при котором разметка в файле *Razor* преобразуется в процедурную C# логику. Во время выполнения C# логика создает *дерево отрисовки* , описывающее элементы, текст и дочерние компоненты. Это применяется к DOM браузера через последовательность инструкций JavaScript (или сериализуется в HTML в случае предварительной визуализации):

* Пользовательский ввод, отображаемый с помощью обычных синтаксис Razor ( `@someStringValue`например,), не предоставляет уязвимость XSS, так как синтаксис Razor добавляется в DOM с помощью команд, которые могут записывать только текст. Даже если значение включает HTML-разметку, значение отображается как статический текст. При предварительной отрисовке выходные данные кодируются в формате HTML, что также отображает содержимое в виде статического текста.
* Теги скриптов не допускаются и не должны включаться в дерево визуализации компонента приложения. Если тег скрипта включен в разметку компонента, создается ошибка времени компиляции.
* Авторы компонентов могут создавать компоненты C# без использования Razor. Автор компонента несет ответственность за использование правильных API-интерфейсов при выдаче выходных данных. Например, используйте `builder.AddContent(0, someUserSuppliedString)` , а *не* `builder.AddMarkupContent(0, someUserSuppliedString)`, так как в последнем случае может быть создана уязвимость XSS.

В рамках защиты от атак XSS рассмотрите возможность реализации предотвращения взлома XSS, например [политики безопасности содержимого (CSP)](https://developer.mozilla.org/docs/Web/HTTP/CSP).

Дополнительные сведения см. в разделе <xref:security/cross-site-scripting>.

### <a name="cross-origin-protection"></a>Защита от разных источников

Атаки между источниками предполагают, что клиент из другого источника выполняет действие с сервером. Вредоносным действием обычно является запрос GET или форма POST (подделка межсайтовых запросов, CSRF), но также возможен открытие вредоносного WebSocket. Серверные приложения блазор предлагают [те же гарантии, что и любое другое приложение SignalR, использующее предложение по протоколу концентратора](xref:signalr/security):

* Доступ к серверным приложениям блазор можно получить из нескольких источников, если только не будут предприняты дополнительные меры для их предотвращения. Чтобы отключить доступ между источниками, отключите CORS в конечной точке, добавив по промежуточного слоя CORS в конвейер и добавив `DisableCorsAttribute` в метаданные конечной точки блазор или ограничив набор разрешенных источников, [настроив SignalR для ресурса между источниками. Общий доступ](xref:signalr/security#cross-origin-resource-sharing).
* Если CORS включен, для защиты приложения могут потребоваться дополнительные действия в зависимости от конфигурации CORS. Если CORS глобально включена, CORS можно отключить для центра сервера блазор, добавив `DisableCorsAttribute` метаданные в метаданные конечной точки после вызова. `hub.MapBlazorHub()`

Дополнительные сведения см. в разделе <xref:security/anti-request-forgery>.

### <a name="click-jacking"></a>Щелчок

При нажатии кнопки «гнездо» выполняется подготовка сайта `<iframe>` к просмотру внутри сайта с другого источника, чтобы заставить пользователя выполнять действия на веб-узле при атаке.

Чтобы защитить приложение от подготовки к просмотру `<iframe>`в, используйте [политику безопасности содержимого (CSP](https://developer.mozilla.org/docs/Web/HTTP/CSP) `X-Frame-Options` ) и заголовок. Дополнительные сведения см. в [разделе веб-документы MDN: Параметры](https://developer.mozilla.org/docs/Web/HTTP/Headers/X-Frame-Options)X-Frame-.

### <a name="open-redirects"></a>Открыть перенаправления

При запуске сеанса серверного приложения Блазор сервер выполняет базовую проверку URL-адресов, отправляемых в процессе запуска сеанса. Платформа проверяет, является ли базовый URL-адрес родительским по отношению к текущему URL-адресу, прежде чем устанавливать канал. Платформа не выполняет никаких дополнительных проверок.

Когда пользователь выбирает ссылку на клиенте, URL-адрес ссылки отправляется на сервер, который определяет, какое действие следует предпринять. Например, приложение может выполнить навигацию на стороне клиента или указать браузеру, чтобы перейти к новому расположению.

Компоненты также могут запускать запросы навигации программно с помощью `NavigationManager`. В таких случаях приложение может выполнить навигацию на стороне клиента или указать браузеру, чтобы перейти к новому расположению.

Компоненты должны:

* Старайтесь не использовать входные данные пользователя как часть аргументов вызова навигации.
* Проверьте аргументы, чтобы убедиться, что целевой объект разрешен приложением.

В противном случае злонамеренный пользователь может заставить браузер попасть на управляемый злоумышленником сайт. В этом случае злоумышленник применяет приложение к использованию некоторых входных данных, вводимых пользователем, в ходе вызова `NavigationManager.Navigate` метода.

Этот Совет также применяется при подготовке к просмотру ссылок в составе приложения:

* По возможности используйте относительные ссылки.
* Убедитесь, что ссылки на абсолютные адреса являются допустимыми, прежде чем включать их в страницу.

Дополнительные сведения см. в разделе <xref:security/preventing-open-redirects>.

## <a name="authentication-and-authorization"></a>Аутентификация и авторизация

Рекомендации по проверке подлинности и авторизации <xref:security/blazor/index>см. в разделе.

## <a name="security-checklist"></a>Контрольный список безопасности

Следующий список вопросов безопасности не является исчерпывающим:

* Проверка аргументов из событий.
* Проверка входных данных и результатов вызовов взаимодействия JS.
* Старайтесь не использовать (или проверять заранее) пользовательский ввод для вызовов взаимодействия .NET to JS.
* Запретить клиенту выделение непривязанного объема памяти.
  * Данные в компоненте.
  * `DotNetObject`ссылки, возвращаемые клиенту.
* Защита от нескольких диспетчеризации.
* Отмена длительных операций при удалении компонента.
* Избегайте событий, создающих большие объемы данных.
* Избегайте использования вводимых пользователем данных в рамках вызовов `NavigationManager.Navigate` и проверки вводимых пользователем данных для URL-адресов с набором разрешенных источников сначала, если это не так.
* Не следует принимать решения об авторизации на основе состояния пользовательского интерфейса, но только из состояния компонента.
* Рассмотрите возможность использования [политики безопасности содержимого (CSP)](https://developer.mozilla.org/docs/Web/HTTP/CSP) для защиты от атак XSS.
* Используйте CSP и [X-Frame-параметры](https://developer.mozilla.org/docs/Web/HTTP/Headers/X-Frame-Options) для защиты от щелчков.
* Убедитесь, что параметры CORS подходят при включении CORS или явном отключении CORS для приложений Блазор.
* Проверьте, что ограничения на стороне сервера для приложения Блазор обеспечивают приемлемое взаимодействие с пользователем без неприемлемых уровней риска.
