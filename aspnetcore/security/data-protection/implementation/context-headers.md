---
title: Заголовки контекста в ASP.NET Core
author: rick-anderson
description: Сведения о реализации ASP.NET Core заголовков контекста защиты данных.
ms.author: riande
ms.date: 10/14/2016
uid: security/data-protection/implementation/context-headers
ms.openlocfilehash: 518423f5df93924d3df144994e4beb1755cd0bfc
ms.sourcegitcommit: 9a129f5f3e31cc449742b164d5004894bfca90aa
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78654580"
---
# <a name="context-headers-in-aspnet-core"></a>Заголовки контекста в ASP.NET Core

<a name="data-protection-implementation-context-headers"></a>

## <a name="background-and-theory"></a>Фон и теория

В системе защиты данных "ключ" означает объект, который может предоставлять службы шифрования, прошедшие проверку подлинности. Каждый ключ идентифицируется с помощью уникального идентификатора (GUID) и включает в себя ИТ-алгоритмную информацию и энтропию. Предполагается, что каждый ключ имеет уникальную энтропию, но система не может их применить, и нам также нужно учитывать, что для разработчиков, которые могут изменить ключевое кольцо вручную, путем изменения алгоритма данных существующего ключа в кольце ключа. Для достижения требований безопасности в этих случаях система защиты данных имеет концепцию [криптографической гибкости](https://www.microsoft.com/en-us/research/publication/cryptographic-agility-and-its-relation-to-circular-encryption/), которая позволяет безопасно использовать одно значение энтропии в нескольких алгоритмах шифрования.

Большинство систем, поддерживающих гибкость криптографии, делают это, включая некоторые идентифицирующие сведения о алгоритме в полезных данных. Как правило, этот идентификатор является хорошим кандидатом для этого. Однако одна из проблем, с которыми мы столкнулись, заключается в том, что существует несколько способов указать один и тот же алгоритм: "AES" (CNG), а управляемые классы AES, AesManaged, AesCryptoServiceProvider, AesCng и RijndaelManaged (заданные конкретные параметры) фактически одинаковы. и нам нужно поддерживать сопоставление всех этих объектов с правильным идентификатором OID. Если разработчик хочет предоставить пользовательский алгоритм (или даже другую реализацию AES!), ему пришлось бы сообщить нам свой идентификатор OID. Этот дополнительный шаг регистрации делает конфигурацию системы особенно ненужной.

При пошаговом выполнении мы решили, что мы разрешили проблему в неправильном направлении. OID сообщает, что представляет собой алгоритм, но на самом деле это не важно. Если необходимо безопасно использовать одно значение энтропии в двух разных алгоритмах, нет необходимости знать, что именно представляют собой алгоритмы. В действительности мы будем заниматься тем, как они ведут себя. Любой недопустимый симметричный алгоритм блочного шифрования — это также строгая псевдослучайноеая перестановка (политику репликации паролей). Исправьте входные данные (режим "ключ", "цепочка", "IV" и "обычный текст") и вывод зашифрованного текста с перегруженной вероятностью будет отличаться от алгоритм, в котором одни и те же входные данные. Аналогичным образом любая функция хэширования с любыми ключевыми ключами также является строгой функцией псевдослучайное (PRF), и при указании фиксированного входного набора его выходные данные будут совершенно отличаться от любых других хэш-функций с ключом.

Мы используем эту концепцию strong PRP и Прфс для создания заголовка контекста. Этот заголовок контекста, по сути, действует как стабильный отпечаток по сравнению с алгоритмами, используемыми для любой конкретной операции, и обеспечивает гибкость шифрования, необходимую системе защиты данных. Этот заголовок воспроизводится воспроизводимым образом и используется позже как часть [процесса наследования подраздела](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation). Существует два разных способа построения заголовка контекста в зависимости от режимов работы базовых алгоритмов.

## <a name="cbc-mode-encryption--hmac-authentication"></a>Шифрование в режиме CBC + проверка подлинности HMAC

<a name="data-protection-implementation-context-headers-cbc-components"></a>

Заголовок контекста состоит из следующих компонентов:

* [16 бит] Значение 00 00, которое является маркером, означающее "шифрование CBC + HMAC Authentication".

* [32 бит] Длина ключа (в байтах с обратным порядком байтов) для алгоритма симметричного блочного шифра.

* [32 бит] Размер блока (в байтах с обратным порядком байтов) для алгоритма симметричного блочного шифра.

* [32 бит] Длина ключа (в байтах с обратным порядком байтов) для алгоритма HMAC. (В настоящее время размер ключа всегда совпадает с размером дайджеста.)

* [32 бит] Размер дайджеста (в байтах с обратным порядком байтов) для алгоритма HMAC.

* Енккбк (K_E, IV, ""), который является выходным значением алгоритма симметричного блочного шифра, учитывая входную пустую строку и где IV является нулевым вектором. Конструкция K_E описана ниже.

* MAC (K_H, ""), который является выходным результатом алгоритма HMAC по заданному входу пустой строки. Конструкция K_H описана ниже.

В идеале мы можем передать все нулевые векторы для K_E и K_H. Однако мы хотим избежать ситуации, когда базовый алгоритм проверяет наличие слабых ключей перед выполнением любых операций (особенно DES и 3DES), которые не могут использовать простой или повторяемый шаблон, такой как «все-ноль».

Вместо этого мы используем директиву NIST SP800-108 ПОДПРОГРАММ в режиме счетчика (см. директивы [NIST SP800-108](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec. 5,1) с нулевой длиной ключа, метки и контекста и HMACSHA512 в качестве базового PRF. Наследуется | K_E | + | K_H | байты выходных данных, после чего результат разбивается на K_E и K_H. В математическом виде это представлено следующим образом.

(K_E | | K_H) = SP800_108_CTR (PRF = HMACSHA512, Key = "", метка = "", context = "")

### <a name="example-aes-192-cbc--hmacsha256"></a>Пример: AES-192-CBC + HMACSHA256

В качестве примера рассмотрим случай, когда алгоритм симметричного блочного шифра — AES-192-CBC, а алгоритм проверки — HMACSHA256. Система создаст заголовок контекста, выполнив следующие действия.

Во-первых, Let (K_E | | K_H) = SP800_108_CTR (PRF = HMACSHA512, Key = "", метка = "", context = ""), где | K_E | = 192 бит и | K_H | = 256 бит на указанные алгоритмы. Это ведет к K_E = 5BB6.. 21DD и K_H = A04A.. 00A9 в следующем примере:

```
5B B6 C9 83 13 78 22 1D 8E 10 73 CA CF 65 8E B0
61 62 42 71 CB 83 21 DD A0 4A 05 00 5B AB C0 A2
49 6F A5 61 E3 E2 49 87 AA 63 55 CD 74 0A DA C4
B7 92 3D BF 59 90 00 A9
```

Затем COMPUTE Enc_CBC (K_E, IV, "") для AES-192-CBC, заданный IV = 0 * и K_E, как показано выше.

result := F474B1872B3B53E4721DE19C0841DB6F

Затем COMPUTE MAC (K_H, "") для HMACSHA256 заданный K_H как описано выше.

result := D4791184B996092EE1202F36E8608FA8FBD98ABDFF5402F264B1D7211536220C

В результате будет получен заголовок полного контекста ниже:

```
00 00 00 00 00 18 00 00 00 10 00 00 00 20 00 00
00 20 F4 74 B1 87 2B 3B 53 E4 72 1D E1 9C 08 41
DB 6F D4 79 11 84 B9 96 09 2E E1 20 2F 36 E8 60
8F A8 FB D9 8A BD FF 54 02 F2 64 B1 D7 21 15 36
22 0C
```

Этот заголовок контекста представляет собой отпечаток пары алгоритмов шифрования с проверкой подлинности (AES-192-CBC Encryption + HMACSHA256). Ниже перечислены компоненты, описанные [выше](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers-cbc-components) .

* маркер (00 00)

* Длина ключа блочного шифра (00 00 00 18)

* Размер блока блочного шифра (00 00 00 10)

* Длина ключа HMAC (00 00 00 20)

* Размер дайджеста HMAC (00 00 00 20)

* выходные данные блочного шифра репликации паролей (F4 74-DB 6F) и

* выходные данные HMAC PRF (D4 79-End).

> [!NOTE]
> Заголовок контекста проверки подлинности шифрования и HMAC в режиме CBC создается одинаково независимо от того, предоставляются ли реализации алгоритмов Windows CNG или управляемыми типами SymmetricAlgorithm и KeyedHashAlgorithm. Это позволяет приложениям, работающим в разных операционных системах, надежно создавать один и тот же заголовок контекста, даже несмотря на то, что реализации алгоритмов отличаются в разных ОС. (На практике KeyedHashAlgorithm не обязательно должен быть правильным HMAC. Это может быть любой тип хэш-алгоритма с ключом.)

### <a name="example-3des-192-cbc--hmacsha1"></a>Пример: 3DES-192-CBC + HMACSHA1

Во-первых, Let (K_E | | K_H) = SP800_108_CTR (PRF = HMACSHA512, Key = "", метка = "", context = ""), где | K_E | = 192 бит и | K_H | = 160 бит на указанные алгоритмы. Это ведет к K_E = A219.. E2BB и K_H = DC4A.. B464 в следующем примере:

```
A2 19 60 2F 83 A9 13 EA B0 61 3A 39 B8 A6 7E 22
61 D9 F8 6C 10 51 E2 BB DC 4A 00 D7 03 A2 48 3E
D1 F7 5A 34 EB 28 3E D7 D4 67 B4 64
```

Затем COMPUTE Enc_CBC (K_E, IV, "") для 3DES-192-CBC, заданный IV = 0 * и K_E, как показано выше.

результат: = ABB100F81E53E10E

Затем COMPUTE MAC (K_H, "") для HMACSHA1 заданный K_H как описано выше.

результат: = 76EB189B35CF03461DDF877CD9F4B1B4D63A7555

При этом создается полный заголовок контекста, который является отпечатком пары алгоритмов шифрования с проверкой подлинности (3DES-192-CBC + HMACSHA1 Validation), как показано ниже:

```
00 00 00 00 00 18 00 00 00 08 00 00 00 14 00 00
00 14 AB B1 00 F8 1E 53 E1 0E 76 EB 18 9B 35 CF
03 46 1D DF 87 7C D9 F4 B1 B4 D6 3A 75 55
```

Компоненты разбивается на следующие:

* маркер (00 00)

* Длина ключа блочного шифра (00 00 00 18)

* Размер блока блочного шифра (00 00 00 08)

* Длина ключа HMAC (00 00 00 14)

* Размер дайджеста HMAC (00 00 00 14)

* выходные данные блокирующего шифра репликации (AB B1-E1 0E) и

* выходные данные HMAC PRF (76 EB-End).

## <a name="galoiscounter-mode-encryption--authentication"></a>Галоис/шифрование в режиме счетчика + аутентификация

Заголовок контекста состоит из следующих компонентов:

* [16 бит] Значение 00 01, которое является маркером "шифрование GCM + проверка подлинности".

* [32 бит] Длина ключа (в байтах с обратным порядком байтов) для алгоритма симметричного блочного шифра.

* [32 бит] Размер nonce (в байтах с обратным порядком байтов), используемый во время операций шифрования, прошедших проверку подлинности. (Для нашей системы это исправлено на nonce size = 96 бит.)

* [32 бит] Размер блока (в байтах с обратным порядком байтов) для алгоритма симметричного блочного шифра. (Для GCM это фиксировано в блоке размером = 128 бит.)

* [32 бит] Размер тега проверки подлинности (в байтах с обратным порядком байтов), созданный функцией шифрования с проверкой подлинности. (Для нашей системы это фиксировано по размеру тега = 128 бит.)

* [128 бит] Тег Enc_GCM (K_E, nonce, ""), который является выходным значением алгоритма симметричного блочного шифра, учитывая входную пустую строку, а nonce — 96-разрядный вектор с нулевым значением.

K_E является производным, используя тот же механизм, что и в сценарии проверки подлинности шифрования CBC + HMAC. Однако, так как здесь нет K_H, мы, по сути, настроили | K_H | = 0, а алгоритм сворачивается в следующую форму.

K_E = SP800_108_CTR (PRF = HMACSHA512, Key = "", метка = "", context = "")

### <a name="example-aes-256-gcm"></a>Пример: AES-256-GCM

Сначала позвольте K_E = SP800_108_CTR (PRF = HMACSHA512, Key = "", метка = "", context = ""), где | K_E | = 256 бит.

K_E := 22BC6F1B171C08C4AE2F27444AF8FC8B3087A90006CAEA91FDCFB47C1B8733B8

Затем вычислите тег проверки подлинности Enc_GCM (K_E, nonce, "") для AES-256-GCM, заданный nonce = 096 и K_E, как показано выше.

результат: = E7DCCE66DF855A323A6BB7BD7A59BE45

В результате будет получен заголовок полного контекста ниже:

```
00 01 00 00 00 20 00 00 00 0C 00 00 00 10 00 00
00 10 E7 DC CE 66 DF 85 5A 32 3A 6B B7 BD 7A 59
BE 45
```

Компоненты разбивается на следующие:

* маркер (00 01)

* Длина ключа блочного шифра (00 00 00 20)

* Размер nonce (00 00 00 0C)

* Размер блока блочного шифра (00 00 00 10)

* Размер тега проверки подлинности (00 00 00 10) и

* Тег проверки подлинности от запуска блочного шифра (E7 DC-End).
