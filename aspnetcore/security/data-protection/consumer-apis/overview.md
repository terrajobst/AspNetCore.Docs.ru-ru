---
title: Общие сведения о пользовательских интерфейсах API для ASP.NET Core
author: rick-anderson
description: Получите краткий обзор различных интерфейсов API потребителя, доступных в ASP.NET Coreной библиотеке защиты данных.
ms.author: riande
ms.date: 06/11/2019
uid: security/data-protection/consumer-apis/overview
ms.openlocfilehash: ff9badb55813cae0aa72d3a95dc53792332f109b
ms.sourcegitcommit: 9a129f5f3e31cc449742b164d5004894bfca90aa
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78654586"
---
# <a name="consumer-apis-overview-for-aspnet-core"></a>Общие сведения о пользовательских интерфейсах API для ASP.NET Core

Интерфейсы `IDataProtectionProvider` и `IDataProtector` являются основными интерфейсами, через которые потребители используют систему защиты данных. Они расположены в пакете [Microsoft. AspNetCore. в отношении защиты. абстракций](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.Abstractions/) .

## <a name="idataprotectionprovider"></a>идатапротектионпровидер

Интерфейс поставщика представляет корень системы защиты данных. Его нельзя использовать напрямую для защиты или снятия защиты данных. Вместо этого потребитель должен получить ссылку на `IDataProtector`, вызвав `IDataProtectionProvider.CreateProtector(purpose)`, где назначение — это строка, описывающая предполагаемый вариант использования потребителя. Дополнительные сведения о намерении этого параметра и о том, как выбрать соответствующее значение, см. в разделе [строки назначения](xref:security/data-protection/consumer-apis/purpose-strings) .

## <a name="idataprotector"></a>идатапротектор

Интерфейс предохранителя возвращается вызовом `CreateProtector`, и это интерфейс, который потребители могут использовать для выполнения операций защиты и снятия защиты.

Чтобы защитить фрагмент данных, передайте данные в метод `Protect`. Базовый интерфейс определяет метод, который преобразует Byte [] — > Byte [], но существует также перегрузка (предоставленная в виде метода расширения), преобразующая строку строкового >. Безопасность, предоставляемая двумя методами, идентична. разработчик должен выбрать любую перегрузку, наиболее удобную для своего случая использования. Независимо от выбранной перегрузки, значение, возвращаемое методом Protect, теперь защищено (зашифрованные и искажение), и приложение может отправить его на недоверенный клиент.

Чтобы снять защиту с ранее защищенного фрагмента данных, передайте защищенные данные в метод `Unprotect`. (Для удобства разработчика существуют перегрузки на основе байтов [] и на основе строк.) Если защищенные полезные данные были созданы предыдущим вызовом `Protect` на этом же `IDataProtector`, метод `Unprotect` вернет исходные незащищенные полезные данные. Если защищенные полезные данные были изменены или были созданы другим `IDataProtector`, метод `Unprotect` выдаст CryptographicException.

Концепция одних и тех же и разных `IDataProtector` привязывается к концепции цели. Если два экземпляра `IDataProtector` были созданы из одной и той же корневой `IDataProtectionProvider` но с помощью разных строк назначения в вызове `IDataProtectionProvider.CreateProtector`, они считаются [разными предохранителями](xref:security/data-protection/consumer-apis/purpose-strings), и один из них не сможет снять защиту полезных данных, созданных другим.

## <a name="consuming-these-interfaces"></a>Использование этих интерфейсов

Для компонента, поддерживающего DI, предполагается, что компонент принимает в своем конструкторе параметр `IDataProtectionProvider` и что система DI автоматически предоставляет эту службу при создании экземпляра компонента.

> [!NOTE]
> Некоторые приложения (например, консольные приложения или приложения ASP.NET 4. x) не поддерживают DI, поэтому не могут использовать описанный здесь механизм. В этих сценариях для получения дополнительных сведений о получении экземпляра поставщика `IDataProtection` без использования инструкции ondi см. документацию по [сценариям, не поддерживающим](xref:security/data-protection/configuration/non-di-scenarios) внедрение.

В следующем примере показаны три концепции.

1. [Добавьте систему защиты данных](xref:security/data-protection/configuration/overview) в контейнер службы.

2. Использование метода DI для получения экземпляра `IDataProtectionProvider`и

3. Создание `IDataProtector` из `IDataProtectionProvider` и его использование для защиты и снятия защиты данных.

[!code-csharp[](../using-data-protection/samples/protectunprotect.cs?highlight=26,34,35,36,37,38,39,40)]

Пакет Microsoft. AspNetCore. в отношении защиты. абстракций содержит метод расширения `IServiceProvider.GetDataProtector` в качестве удобства для разработчиков. Он инкапсулируется в качестве одной операции и получает `IDataProtectionProvider` от поставщика услуг и вызывает `IDataProtectionProvider.CreateProtector`. В следующем примере демонстрируется его использование.

[!code-csharp[](./overview/samples/getdataprotector.cs?highlight=15)]

>[!TIP]
> Экземпляры `IDataProtectionProvider` и `IDataProtector` являются потокобезопасными для нескольких вызывающих объектов. Предполагается, что после того, как компонент получает ссылку на `IDataProtector` через вызов `CreateProtector`, он будет использовать эту ссылку для нескольких вызовов `Protect` и `Unprotect`. Вызов `Unprotect` выдаст исключение CryptographicException, если защищенные полезные данные не могут быть проверены или расшифрованы. Некоторым компонентам может потребоваться пропускать ошибки во время операций снятия защиты. компонент, считывающий файлы cookie проверки подлинности, может обработать эту ошибку и обрабатывать запрос так, как если бы он не имел ни одного файла cookie, а не завершать запрос неверно. Компоненты, которые должны использовать это поведение, должны специально перехватывать CryptographicException, а не проглатывание все исключения.
