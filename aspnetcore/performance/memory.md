---
title: Управление памятью и шаблоны в ASP.NET Core
author: rick-anderson
description: Узнайте, как осуществляется управление памятью в ASP.NET Core и как работает сборщик мусора (GC).
ms.author: riande
ms.custom: mvc
ms.date: 11/05/2019
uid: performance/memory
ms.openlocfilehash: 48397e9fe7da912c1930f17fb86b686f0a20c60e
ms.sourcegitcommit: 897d4abff58505dae86b2947c5fe3d1b80d927f3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/06/2019
ms.locfileid: "73638162"
---
# <a name="memory-management-and-garbage-collection-gc-in-aspnet-core"></a>Управление памятью и сборка мусора (GC) в ASP.NET Core

[Сéбастиен рос](https://github.com/sebastienros) и [Рик Андерсон (](https://twitter.com/RickAndMSFT)

Управление памятью является сложной задачей даже в управляемой платформе, такой как .NET. Анализ и понимание проблем с памятью может быть непростой задачей. Эта статья:

* Было вызвано многими *утечками памяти* и *отсутствием проблем в работе GC* . Большинство этих проблем было вызвано не пониманием того, как потребление памяти работает в .NET Core, или не понимание того, как оно измеряется.
* Демонстрирует проблемное использование памяти и предлагает альтернативные подходы.

## <a name="how-garbage-collection-gc-works-in-net-core"></a>Принцип работы сборки мусора в .NET Core

Сборщик мусора выделяет сегменты кучи, в которых каждый сегмент является непрерывным диапазоном памяти. Объекты, помещенные в кучу, делятся на три поколения: 0, 1 или 2. Поколение определяет частоту, с которой сборщик мусора пытается освободить память на управляемых объектах, на которые больше не ссылается приложение. Более низкие номера поколений чаще всего являются GC.

Объекты перемещаются из одного поколения в другое в зависимости от времени их существования. Как только объекты проводятся дольше, они перемещаются в более высокое поколение. Как упоминалось ранее, более высокие поколения являются сборщиком мусора менее часто. Кратковременные объекты с краткосрочным временем существования всегда остаются в поколении 0. Например, кратковременно используются объекты, на которые имеются ссылки в течение жизненного цикла веб-запроса. [Одноэлементные](xref:fundamentals/dependency-injection#service-lifetimes) экземпляры уровня приложения обычно переносятся в поколение 2.

При запуске ASP.NET Coreного приложения сборщик мусора выполняет следующие действия:

* Резервирует некоторый объем памяти для начальных сегментов кучи.
* Фиксирует небольшую часть памяти при загрузке среды выполнения.

Предыдущие выделения памяти выполняются по соображениям производительности. Преимущество производительности состоит из сегментов кучи в непрерывной памяти.

### <a name="call-gccollect"></a>Вызовите GC. Получение

Вызов [GC. Собирайте](xref:System.GC.Collect*) явным образом:

* **Не** следует делать в производственных ASP.NET Core приложениях.
* Полезен при исследовании утечек памяти.
* При исследовании проверяется, что сборщик мусора удалил все висячие объекты из памяти, чтобы можно было измерять память.

## <a name="analyzing-the-memory-usage-of-an-app"></a>Анализ использования памяти приложением

Специальные средства могут помочь в анализе использования памяти:

- Подсчет ссылок на объекты
- Измерение степени влияния сборки мусора на использование ЦП
- Измерение пространства памяти, используемого для каждого поколения

Используйте следующие средства для анализа использования памяти.

* [DotNet-Trace](/dotnet/core/diagnostics/dotnet-trace): может использоваться на рабочих компьютерах.
* [Анализ использования памяти без отладчика Visual Studio](/visualstudio/profiling/memory-usage-without-debugging2)
* [Использование памяти профиля в Visual Studio](/visualstudio/profiling/memory-usage)

### <a name="detecting-memory-issues"></a>Обнаружение проблем с памятью

Диспетчер задач можно использовать для получения представления о том, сколько памяти использует приложение ASP.NET. Значение памяти диспетчера задач:

* Представляет объем памяти, используемый процессом ASP.NET.
* Включает в себя собственные объекты приложения и другие потребители памяти, такие как использование памяти.

Если значение памяти диспетчера задач постоянно увеличивается и никогда не происходит, в приложении возникает утечка памяти. В следующих разделах показаны и описаны некоторые закономерности использования памяти.

## <a name="sample-display-memory-usage-app"></a>Пример приложения для просмотра использования памяти

[Пример приложения меморилеак](https://github.com/sebastienros/memoryleak) доступен на сайте GitHub. Приложение Меморилеак:

* Включает диагностический контроллер, собирающий память Real-Тине и данные GC для приложения.
* Содержит страницу индекса, которая отображает память и данные GC. Страница индекса обновляется каждую секунду.
* Содержит контроллер API, который предоставляет различные шаблоны нагрузки для памяти.
* Не является поддерживаемым средством, однако его можно использовать для просмотра шаблонов использования памяти ASP.NET Core приложений.

Запустите Меморилеак. Выделенная память медленно увеличивается, пока не произойдет GC. Память увеличивается, поскольку средство выделяет пользовательский объект для записи данных. На следующем рисунке показана страница индекса Меморилеак при возникновении сборки мусора Gen 0. На диаграмме показано 0 RPS (запросов в секунду), так как не были вызваны конечные точки API из контроллера API.

![Предыдущая диаграмма](memory/_static/0RPS.png)

На диаграмме показаны два значения использования памяти:

- Выделение: объем памяти, занятой управляемыми объектами
- Рабочий набор: общий объем физической памяти (ОЗУ), используемый процессом. Отображаемый рабочий набор — это то же значение, которое Диспетчер задач может отобразить.

### <a name="transient-objects"></a>Временные объекты

Следующий API создает экземпляр строки размером 10 КБ и возвращает его клиенту. При каждом запросе новый объект выделяется в памяти и записывается в ответ. Строки хранятся в .NET в виде символов UTF-16, поэтому каждый символ занимает 2 байта в памяти.

```csharp
[HttpGet("bigstring")]
public ActionResult<string> GetBigString()
{
    return new String('x', 10 * 1024);
}
```

Следующая диаграмма создается с относительно небольшой нагрузкой в, чтобы продемонстрировать, как это влияет на выделение памяти сборщиком мусора.

![Предыдущая диаграмма](memory/_static/bigstring.png)

На предыдущей диаграмме показано следующее:

* 4 КБ (запросов в секунду).
* Коллекции GC поколения 0 происходят каждые две секунды.
* Рабочий набор является константой приблизительно 500 МБ.
* ЦП равен 12%.
* Потребление памяти и выпуск (через GC) стабильны.

На следующей диаграмме приведена максимальная пропускная способность, которую может обработать компьютер.

![Предыдущая диаграмма](memory/_static/bigstring2.png)

На предыдущей диаграмме показано следующее:

* 22 RPS
* Коллекции GC поколения 0 встречаются несколько раз в секунду.
* Сборки поколения 1 запускаются, так как приложение выделяет значительно больше памяти в секунду.
* Рабочий набор является константой приблизительно 500 МБ.
* ЦП равен 33%.
* Потребление памяти и выпуск (через GC) стабильны.
* ЦП (33%) не используется, поэтому сборка мусора может иметь большое количество выделений.

### <a name="workstation-gc-vs-server-gc"></a>Сборщик мусора рабочей станции и сервер GC

Сборщик мусора .NET имеет два разных режима:

* **Сборщик мусора рабочей станции**: оптимизирован для настольных систем.
* **GC сервера**. Глобальный каталог по умолчанию для приложений ASP.NET Core. Оптимизировано для сервера.

Режим GC можно задать явным образом в файле проекта или в файле *runtimeconfig. JSON* опубликованного приложения. В следующей разметке показана настройка `ServerGarbageCollection` в файле проекта:

```xml
<PropertyGroup>
  <ServerGarbageCollection>true</ServerGarbageCollection>
</PropertyGroup>
```

Для изменения `ServerGarbageCollection` в файле проекта требуется Перестроение приложения.

**Примечание.** Сборка мусора сервера **недоступна** на компьютерах с одним ядром. Для получения дополнительной информации см. <xref:System.Runtime.GCSettings.IsServerGC>.

На следующем рисунке показан профиль памяти в 5 КБ RPS с помощью сборщика мусора рабочей станции.

![Предыдущая диаграмма](memory/_static/workstation.png)

Различия между этой диаграммой и версией сервера существенны:

- Рабочий набор удаляется с 500 МБ до 70 МБ.
- Сборщик мусора выделает коллекции поколения 0 несколько раз в секунду, а не каждые две секунды.
- GC перепадает с 300 МБ на 10 МБ.

В типичной среде веб-сервера загрузка ЦП важнее, чем память, поэтому сервер GC лучше. Если интенсивность использования памяти высока и загрузка ЦП относительно низкая, то сборщик мусора рабочей станции может быть более производительным. Например, высокая плотность размещения нескольких веб-приложений, где недостаточно памяти.

### <a name="persistent-object-references"></a>Постоянные ссылки на объекты

Сборщику мусора не удается освободить объекты, на которые имеются ссылки. Объекты, на которые имеются ссылки, но которые больше не нужны, приводят к утечке памяти. Если приложение часто выделяет объекты и не может освободить их после того, как они больше не нужны, использование памяти увеличится со временем.

Следующий API создает экземпляр строки размером 10 КБ и возвращает его клиенту. Разница с предыдущим примером заключается в том, что на этот экземпляр ссылается статический член, что означает, что он никогда не доступен для коллекции.

```csharp
private static ConcurrentBag<string> _staticStrings = new ConcurrentBag<string>();

[HttpGet("staticstring")]
public ActionResult<string> GetStaticString()
{
    var bigString = new String('x', 10 * 1024);
    _staticStrings.Add(bigString);
    return bigString;
}
```

Предыдущий код:

* — Пример типичной утечки памяти.
* При частом вызове происходит увеличение объема памяти приложения до аварийного завершения процесса с исключением `OutOfMemory`.

![Предыдущая диаграмма](memory/_static/eternal.png)

На предыдущем рисунке:

* Нагрузочное тестирование конечная точка `/api/staticstring` вызывает линейное увеличение памяти.
* Сборщик мусора пытается освободить память по мере роста нехватки памяти путем вызова сборки поколения 2.
* Сборщику мусора не удается освободить утечку памяти. Увеличение выделенного и рабочего набора с учетом времени.

В некоторых сценариях, таких как кэширование, требуется, чтобы ссылки на объекты удерживались до тех пор, пока не будет принудительно снята нагрузка на память. Для этого типа кода кэширования можно использовать класс <xref:System.WeakReference>. Объект `WeakReference` собирается при нехватке памяти. Реализация <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache> по умолчанию использует `WeakReference`.

### <a name="native-memory"></a>Собственная память

Некоторые объекты .NET Core основываются на собственной памяти. Встроенная память **не** может быть СОБРАНа сборщиком мусора. Объект .NET, использующий собственную память, должен освободить его с помощью машинного кода.

.NET предоставляет <xref:System.IDisposable> интерфейс, позволяющий разработчикам освобождать собственную память. Даже если <xref:System.IDisposable.Dispose*> не вызывается, правильно реализованные классы вызывают `Dispose`, когда выполняется [метод завершения](/dotnet/csharp/programming-guide/classes-and-structs/destructors) .

Рассмотрим следующий код.

```csharp
[HttpGet("fileprovider")]
public void GetFileProvider()
{
    var fp = new PhysicalFileProvider(TempPath);
    fp.Watch("*.*");
}
```

[Фисикафилепровидер](/dotnet/api/microsoft.extensions.fileproviders.physicalfileprovider?view=dotnet-plat-ext-3.0) является управляемым классом, поэтому в конце запроса будет собираться любой экземпляр.

На следующем рисунке показан профиль памяти при постоянном вызове API `fileprovider`.

![Предыдущая диаграмма](memory/_static/fileprovider.png)

На предыдущей диаграмме показана очевидная проблема с реализацией этого класса, так как она обеспечивает увеличение использования памяти. Это известная проблема, которая отслеживается в [этой проблеме](https://github.com/aspnet/Home/issues/3110).

Такая же утечка может произойти в пользовательском коде одним из следующих:

* Не освобождайте класс должным образом.
* Не удается вызвать метод `Dispose`зависимых объектов, которые должны быть удалены.

### <a name="large-objects-heap"></a>Куча больших объектов

Частые циклы выделения и освобождения памяти могут фрагментировать память, особенно при выделении больших блоков памяти. Объекты выделяются в смежных блоках памяти. Чтобы устранить фрагментацию, когда сборщик мусора освобождает память, он трис ее дефрагментацию. Этот процесс называется **сжатием**. Сжатие включает в себя перемещение объектов. Перемещение больших объектов накладывает снижение производительности. По этой причине сборщик мусора создает специальную зону памяти для _больших_ объектов, которая называется [кучей больших объектов](/dotnet/standard/garbage-collection/large-object-heap) (LOH). Объекты размером более 85 000 байт (примерно 83 КБ):

* Размещается в LOH.
* Не сжато.
* Собраны во время сборки мусора поколения 2.

Когда LOH заполнена, сборщик мусора запускает сборку поколения 2. Коллекции поколения 2:

* По сути являются медленными.
* Кроме того, следует взимать затраты на активацию коллекции во всех других поколениях.

Следующий код немедленно сжимает LOH:

```csharp
GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;
GC.Collect();
```

Сведения о сжатии LOH см. в разделе <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode>.

В контейнерах, использующих .NET Core 3,0 и более поздних версий, LOH автоматически сжимается.

Следующий API демонстрирует такое поведение:

```csharp
[HttpGet("loh/{size=85000}")]
public int GetLOH1(int size)
{
   return new byte[size].Length;
}
```

На следующей диаграмме показан профиль памяти для вызова конечной точки `/api/loh/84975` в разделе максимальная нагрузка:

![Предыдущая диаграмма](memory/_static/loh1.png)

На следующей диаграмме показан профиль памяти для вызова конечной точки `/api/loh/84976`, который выделяет еще *один байт*:

![Предыдущая диаграмма](memory/_static/loh2.png)

Примечание. Структура `byte[]` содержит служебные байты. Вот почему 84 976 байта вызывает ограничение 85 000.

Сравнение двух предыдущих диаграмм:

* Рабочий набор аналогичен обоим сценариям, примерно 450 МБ.
* В разделе запросы LOH (84 975 байт) показаны в основном коллекции поколения 0.
* При чрезмерном запросе LOH генерируются коллекции констант поколения 2. Коллекции поколения 2 являются дорогостоящими. Требуется больше ресурсов ЦП, и пропускная способность падает почти на 50%.

Временные крупные объекты особенно проблематичны, так как они вызывают Gen2 GC.

Для максимальной производительности использование большого объекта должно быть минимальным. Если возможно, разделите большие объекты. Например, по промежуточного слоя [кэширования ответа](xref:performance/caching/response) в ASP.NET Core Разделите записи кэша на блоки менее 85 000 байт.

Следующие ссылки показывают ASP.NET Core подходе к хранению объектов под пределами LOH:
- [Респонсекачинг/Streams/Стреамутилитиес. CS](https://github.com/aspnet/AspNetCore/blob/v3.0.0/src/Middleware/ResponseCaching/src/Streams/StreamUtilities.cs#L16)
- [Респонсекачинг/Мемориреспонсекаче. CS](https://github.com/aspnet/ResponseCaching/blob/c1cb7576a0b86e32aec990c22df29c780af29ca5/src/Microsoft.AspNetCore.ResponseCaching/Internal/MemoryResponseCache.cs#L55)

Дополнительные сведения см. на странице

* [Обнаружена куча больших объектов](https://devblogs.microsoft.com/dotnet/large-object-heap-uncovered-from-an-old-msdn-article/)
* [Куча больших объектов](/dotnet/standard/garbage-collection/large-object-heap)

### <a name="httpclient"></a>HttpClient

Неправильное использование <xref:System.Net.Http.HttpClient> может привести к утечке ресурсов. Системные ресурсы, такие как подключения к базам данных, сокеты, дескрипторы файлов и т. д.:

* Больше, чем память.
* Более проблематично, если утечка по сравнению с памятью.

Опытным разработчикам .NET известна возможность вызова <xref:System.IDisposable.Dispose*> для объектов, реализующих <xref:System.IDisposable>. Отсутствие удаления объектов, которые реализуют `IDisposable` обычно приводит к утечке памяти или утечке системных ресурсов.

`HttpClient` реализует `IDisposable`, но **не** следует удалять при каждом вызове. Вместо этого `HttpClient` следует использовать повторно.

Следующая Конечная точка создает и уничтожает новый экземпляр `HttpClient` при каждом запросе:

```csharp
[HttpGet("httpclient1")]
public async Task<int> GetHttpClient1(string url)
{
    using (var httpClient = new HttpClient())
    {
        var result = await httpClient.GetAsync(url);
        return (int)result.StatusCode;
    }
}
```

В разделе Загрузка регистрируются следующие сообщения об ошибках:

```
fail: Microsoft.AspNetCore.Server.Kestrel[13]
      Connection id "0HLG70PBE1CR1", Request id "0HLG70PBE1CR1:00000031":
      An unhandled exception was thrown by the application.
System.Net.Http.HttpRequestException: Only one usage of each socket address
    (protocol/network address/port) is normally permitted --->
    System.Net.Sockets.SocketException: Only one usage of each socket address
    (protocol/network address/port) is normally permitted
   at System.Net.Http.ConnectHelper.ConnectAsync(String host, Int32 port,
    CancellationToken cancellationToken)
```

Несмотря на то, что экземпляры `HttpClient` удаляются, фактическое сетевое подключение занимает некоторое время, выпуская операционной системой. При непрерывном создании новых соединений происходит _нехватка портов_ . Для каждого клиентского соединения требуется свой порт клиента.

Одним из способов предотвращения нехватки портов является повторное использование того же экземпляра `HttpClient`:

```csharp
private static readonly HttpClient _httpClient = new HttpClient();

[HttpGet("httpclient2")]
public async Task<int> GetHttpClient2(string url)
{
    var result = await _httpClient.GetAsync(url);
    return (int)result.StatusCode;
}
```

Экземпляр `HttpClient` освобождается при остановке приложения. В этом примере показано, что не каждый удаляемый ресурс должен быть удален после каждого использования.

Дополнительные сведения об обработке времени существования экземпляра `HttpClient` см. в следующих статьях:

* [HttpClient и управление жизненным циклом](/aspnet/core/fundamentals/http-requests#httpclient-and-lifetime-management)
* [Блог фабрики HTTPClient](https://devblogs.microsoft.com/aspnet/asp-net-core-2-1-preview1-introducing-httpclient-factory/)
 
### <a name="object-pooling"></a>Объединение объектов в пул

В предыдущем примере показано, как экземпляр `HttpClient` можно сделать статическим и повторно использовать во всех запросах. Повторное использование не доблокирует ресурсы.

Объединение объектов в пул:

* Использует шаблон повторного использования.
* Предназначен для объектов, которые могут создаваться дорого.

Пул — это коллекция предварительно инициализированных объектов, которые можно зарезервировать и освободить в потоках. Пулы могут определять правила распределения, такие как ограничения, предопределенные размеры или скорость роста.

Пакет NuGet [Microsoft. Extensions. обжектпул](https://www.nuget.org/packages/Microsoft.Extensions.ObjectPool/) содержит классы, помогающие управлять такими пулами.

Следующая Конечная точка API создает экземпляр буфера `byte`, который заполняется случайными числами для каждого запроса:

```csharp
        [HttpGet("array/{size}")]
        public byte[] GetArray(int size)
        {
            var random = new Random();
            var array = new byte[size];
            random.NextBytes(array);

            return array;
        }
```

На следующей диаграмме показан вызов предыдущего API с умеренной нагрузкой:

![Предыдущая диаграмма](memory/_static/array.png)

На приведенной выше диаграмме сборки поколения 0 происходят приблизительно в секунду.

Приведенный выше код можно оптимизировать путем объединения `byte`ного буфера с помощью [`ArrayPool<T>`](xref:System.Buffers.ArrayPool`1). Статический экземпляр повторно используется в запросах.

В отличие от этого подхода, объект poold возвращается из API. Это означает:

* Объект находится вне элемента управления, как только вы вернетесь из метода.
* Вы не можете освободить объект.

Чтобы настроить удаление объекта, выполните следующие действия.

* Инкапсулирует массив в пуле в удаляемый объект.
* Зарегистрируйте объект poold с помощью [HttpContext. Response. регистерфордиспосе](xref:Microsoft.AspNetCore.Http.HttpResponse.RegisterForDispose*).

`RegisterForDispose` позаботится о вызове `Dispose`для целевого объекта, чтобы он выпускался только после завершения HTTP-запроса.

```csharp
private static ArrayPool<byte> _arrayPool = ArrayPool<byte>.Create();

private class PooledArray : IDisposable
{
    public byte[] Array { get; private set; }

    public PooledArray(int size)
    {
        Array = _arrayPool.Rent(size);
    }

    public void Dispose()
    {
        _arrayPool.Return(Array);
    }
}

[HttpGet("pooledarray/{size}")]
public byte[] GetPooledArray(int size)
{
    var pooledArray = new PooledArray(size);

    var random = new Random();
    random.NextBytes(pooledArray.Array);

    HttpContext.Response.RegisterForDispose(pooledArray);

    return pooledArray.Array;
}
```

Применение той же нагрузки, что и версия без пула, приводит к следующей диаграмме:

![Предыдущая диаграмма](memory/_static/pooledarray.png)

Основное различие состоит в том, что выделяется байты, и в итоге число сборок поколения 0 будет значительно меньше.

## <a name="additional-resources"></a>Дополнительные ресурсы

* [Сборка мусора](/dotnet/standard/garbage-collection/)
* [Основные сведения о различных режимах сборки мусора с помощью визуализатора параллелизма](https://blogs.msdn.microsoft.com/seteplia/2017/01/05/understanding-different-gc-modes-with-concurrency-visualizer/)
* [Обнаружена куча больших объектов](https://devblogs.microsoft.com/dotnet/large-object-heap-uncovered-from-an-old-msdn-article/)
* [Куча больших объектов](/dotnet/standard/garbage-collection/large-object-heap)
