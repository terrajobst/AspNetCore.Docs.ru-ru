---
title: Рекомендации по повышению производительности ASP.NET Core
author: mjrousos
description: Советы по повышению производительности ASP.NET Core приложений и устранению распространенных проблем с производительностью.
monikerRange: '>= aspnetcore-2.1'
ms.author: riande
ms.date: 12/05/2019
no-loc:
- SignalR
uid: performance/performance-best-practices
ms.openlocfilehash: bd30776d527b4ac9f44005e9f5d03fec7cfda2e6
ms.sourcegitcommit: c0b72b344dadea835b0e7943c52463f13ab98dd1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/06/2019
ms.locfileid: "74880922"
---
# <a name="aspnet-core-performance-best-practices"></a>Рекомендации по повышению производительности ASP.NET Core

По [Майк Роусос](https://github.com/mjrousos)

В этой статье приводятся рекомендации по обеспечению оптимальной производительности с помощью ASP.NET Core.

## <a name="cache-aggressively"></a>Агрессивный кэш

Кэширование рассматривается в нескольких частях этого документа. Для получения дополнительной информации см. <xref:performance/caching/response>.

## <a name="understand-hot-code-paths"></a>Общие сведения о путях к горячему коду

В этом документе путь к *горячему коду* определяется как часто называемый путь к коду и где возникает большая часть времени выполнения. Пути с горячим кодом обычно ограничивают масштаб и производительность приложения и обсуждаются в нескольких частях этого документа.

## <a name="avoid-blocking-calls"></a>Избегайте блокирующих вызовов

ASP.NET Core приложения предназначены для одновременной обработки нескольких запросов. Асинхронные интерфейсы API позволяют небольшому пулу потоков работать с тысячами одновременных запросов, не дожидаясь блокировки вызовов. Вместо ожидания завершения длительной синхронной задачи поток может работать с другим запросом.

Распространенная проблема производительности в ASP.NET Core приложениях — блокировка вызовов, которые могут быть асинхронными. Многие синхронные блокирующие вызовы ведут к нехватке [пула потоков](https://blogs.msdn.microsoft.com/vancem/2018/10/16/diagnosing-net-core-threadpool-starvation-with-perfview-why-my-service-is-not-saturating-all-cores-or-seems-to-stall/) и снижению времени отклика.

**Не выполнять**:

* Блокировать асинхронное выполнение путем вызова [Task. Wait](/dotnet/api/system.threading.tasks.task.wait) или [Task. Result](/dotnet/api/system.threading.tasks.task-1.result).
* Получение блокировок в общих путях кода. ASP.NET Core приложения являются наиболее производительными при разработке архитектуры для параллельного выполнения кода.
* Вызовите [Task. Run](/dotnet/api/system.threading.tasks.task.run) и немедленно ожидайте ее. ASP.NET Core уже выполняет код приложения в обычных потоках пула потоков, поэтому вызов задачи. выполнение приведет только к ненужному планированию пула потоков. Даже если запланированный код блокирует поток, Task. Run не препятствует этому.

**Рекомендуется.**

* Сделайте [неактивные пути к коду](#understand-hot-code-paths) асинхронными.
* Асинхронно вызывайте доступ к данным и долгосрочные операции API, если доступен асинхронный API. Опять же, не используйте [Task. Run](/dotnet/api/system.threading.tasks.task.run) , чтобы сделать API синчронус асинхронным.
* Выполнение асинхронных действий контроллера/Razor Page. Весь стек вызовов является асинхронным, чтобы воспользоваться преимуществами шаблонов [async/await](/dotnet/csharp/programming-guide/concepts/async/) .

Профилировщик, например [PerfView](https://github.com/Microsoft/perfview), можно использовать для поиска потоков, часто добавляемых в [пул потоков](/windows/desktop/procthread/thread-pools). Событие `Microsoft-Windows-DotNETRuntime/ThreadPoolWorkerThread/Start` указывает поток, добавленный в пул потоков. <!--  For more information, see [async guidance docs](TBD-Link_To_Davifowl_Doc)  -->

## <a name="minimize-large-object-allocations"></a>Сведение к минимальному выделению больших объектов

[Сборщик мусора .NET Core](/dotnet/standard/garbage-collection/) управляет выделением и освобождением памяти автоматически в ASP.NET Core приложениях. Автоматическая сборка мусора обычно означает, что разработчикам не нужно беспокоиться о том, как или когда освобождается память. Тем не менее очистка объектов, на которые нет ссылок, занимает время ЦП, поэтому разработчики должны максимально сокращать выделение объектов в [путях горячего кода](#understand-hot-code-paths). Сборка мусора особенно затратна на большие объекты (> 85 КБайт). Большие объекты хранятся в [куче больших объектов](/dotnet/standard/garbage-collection/large-object-heap) и для очистки требуется полная сборка мусора (поколение 2). В отличие от коллекций поколений 0 и поколения 1, сборка поколения 2 требует временной приостановки выполнения приложения. Частое выделение и освобождение больших объектов могут привести к нестабильной производительности.

Рекомендации:

* **Рассмотрите возможность** кэширования больших объектов, которые часто используются. Кэширование больших объектов предотвращает дорогостоящее выделение памяти.
* **Сделайте** буферы пула с помощью [аррайпул\<t >](/dotnet/api/system.buffers.arraypool-1) для хранения больших массивов.
* **Не** выделяйте большое количество кратковременных больших объектов в [пути горячего кода](#understand-hot-code-paths).

Проблемы с памятью, например предшествующие, можно диагностировать путем просмотра статистики сборщика мусора (GC) в [PerfView](https://github.com/Microsoft/perfview) и изучения:

* Время остановки сборки мусора.
* Процент времени процессора, затраченный на сборку мусора.
* Количество сборок мусора, которые являются поколением 0, 1 и 2.

Дополнительные сведения см. в разделе [сбор мусора и производительность](/dotnet/standard/garbage-collection/performance).

## <a name="optimize-data-access"></a>Оптимизация доступа к данным

Взаимодействие с хранилищем данных и другими удаленными службами часто является наиболее медленной частью ASP.NET Core приложения. Эффективное чтение и запись данных крайне важно для обеспечения высокой производительности.

Рекомендации:

* **Вызывайте все** API доступа к данным в асинхронном режиме.
* **Не** извлекать больше данных, чем требуется. Напишите запросы, возвращающие только те данные, которые необходимы для текущего HTTP-запроса.
* **Рассмотрите возможность** кэширования часто используемых данных, полученных из базы данных или удаленной службы, если это приемлемо для более неактуальных данных. В зависимости от сценария используйте [MemoryCache](xref:performance/caching/memory) или [DistributedCache](xref:performance/caching/distributed). Для получения дополнительной информации см. <xref:performance/caching/response>.
* **Сократите** круговые обходов сети. Целью является получение необходимых данных в одном вызове, а не в нескольких вызовах.
* **Используйте** [запросы без отслеживания](/ef/core/querying/tracking#no-tracking-queries) в Entity Framework Core при доступе к данным в целях только для чтения. EF Core могут более эффективно возвращать результаты запросов без отслеживания.
* **Выполните** фильтрацию и агрегирование запросов LINQ (например, с помощью `.Where`, `.Select`или инструкций `.Sum`), чтобы фильтрация выполнялась базой данных.
* **Учтите,** что EF Core разрешает некоторые операторы запросов на клиенте, что может привести к неэффективному выполнению запроса. Дополнительные сведения см. в статье [проблемы с производительностью оценки клиента](/ef/core/querying/client-eval#client-evaluation-performance-issues).
* **Не** Используйте проекции запросов к коллекциям, что может привести к выполнению запросов SQL N + 1. Дополнительные сведения см. в разделе [Оптимизация коррелированных вложенных запросов](/ef/core/what-is-new/ef-core-2.1#optimization-of-correlated-subqueries).

Методы, которые могут повысить производительность в крупномасштабных приложениях, см. в статье [Высокая производительность](/ef/core/what-is-new/ef-core-2.0#explicitly-compiled-queries) .

* [Пулы DbContext](/ef/core/what-is-new/ef-core-2.0#dbcontext-pooling)
* [Явно скомпилированные запросы](/ef/core/what-is-new/ef-core-2.0#explicitly-compiled-queries)

Мы рекомендуем оценить влияние предыдущих высокопроизводительных подходов перед фиксацией базы кода. Дополнительная сложность скомпилированных запросов может не отнять повышение производительности.

Проблемы запросов можно обнаружить, просмотрев время, затраченное на доступ к данным с помощью [Application Insights](/azure/application-insights/app-insights-overview) или с помощью средств профилирования. В большинстве баз данных также доступна статистика, касающаяся часто выполняемых запросов.

## <a name="pool-http-connections-with-httpclientfactory"></a>HTTP-соединения пула с Хттпклиентфактори

Хотя [HttpClient](/dotnet/api/system.net.http.httpclient) реализует интерфейс `IDisposable`, он предназначен для повторного использования. Закрытые экземпляры `HttpClient` оставлять сокеты открытыми в `TIME_WAIT` состоянии в течение короткого периода времени. Если часто используется путь кода, который создает и уничтожает объекты `HttpClient`, приложение может вычерпать доступные сокеты. [Хттпклиентфактори](/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests) был представлен в ASP.NET Core 2,1 в качестве решения этой проблемы. Он обрабатывает подключения по протоколу HTTP для оптимизации производительности и надежности.

Рекомендации:

* **Не** Создавайте и удаляйте экземпляры `HttpClient` напрямую.
* **Используйте** [хттпклиентфактори](/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests) для получения экземпляров `HttpClient`. Дополнительные сведения см. [в статье Использование хттпклиентфактори для реализации устойчивых HTTP-запросов](/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests).

## <a name="keep-common-code-paths-fast"></a>Быстрое отслеживание общих путей кода

Необходимо, чтобы весь код был быстрым, часто называемым путями кода, наиболее критичным для оптимизации:

* Компоненты по промежуточного слоя в конвейере обработки запросов приложения, особенно по промежуточного слоя выполняются на раннем этапе конвейера. Эти компоненты сильно влияют на производительность.
* Код, который выполняется для каждого запроса или несколько раз для каждого запроса. Например, пользовательское ведение журнала, обработчики авторизации или инициализацию временных служб.

Рекомендации:

* **Не** используйте пользовательские компоненты промежуточного слоя с долго выполняющимися задачами.
* **Используйте средства** профилирования производительности, такие как [Visual Studio средства диагностики](/visualstudio/profiling/profiling-feature-tour) или [PerfView](https://github.com/Microsoft/perfview)), для указания [путей использования горячих кодов](#understand-hot-code-paths).

## <a name="complete-long-running-tasks-outside-of-http-requests"></a>Выполнение длительных задач за пределами HTTP-запросов

Большинство запросов к ASP.NET Core приложению могут обрабатываться контроллером или моделью страницы, вызывающими необходимые службы и возвращающими ответ HTTP. Для некоторых запросов, в которых задействованы длительные задачи, лучше сделать весь процесс "запрос-ответ" асинхронным.

Рекомендации:

* **Не** дожидаться завершения длительных задач в рамках обычной обработки HTTP-запросов.
* **Рассмотрите возможность** обработки долго выполняющихся запросов с помощью [фоновых служб](xref:fundamentals/host/hosted-services) или вне процесса с помощью [функции Azure](/azure/azure-functions/). Завершение работы вне процесса особенно полезно для ресурсоемких задач.
* Для асинхронной связи с **клиентами используйте параметры** связи в режиме реального времени, например [SignalR](xref:signalr/introduction).

## <a name="minify-client-assets"></a>Ресурсы клиента уменьшение

ASP.NET Core приложения с комплексными внешними интерфейсами часто обслуживают множество файлов JavaScript, CSS или изображений. Производительность запросов начальной загрузки можно улучшить следующим образом.

* Объединение, объединяющее несколько файлов в один.
* Минификация, что сокращает размер файлов, удаляя пробелы и комментарии.

Рекомендации:

* **Используйте** [встроенную поддержку](xref:client-side/bundling-and-minification) ASP.NET Core для объединения и Минификация клиентских ресурсов.
* **Ознакомьтесь с** другими сторонними инструментами, такими как веб- [пакет](https://webpack.js.org/), для комплексного управления клиентскими ресурсами.

## <a name="compress-responses"></a>Сжатие ответов

 Уменьшение размера ответа обычно значительно увеличивает скорость реагирования приложения. Одним из способов уменьшения размера полезных данных является сжатие ответов приложения. Дополнительные сведения см. в разделе [сжатие ответов](xref:performance/response-compression).

## <a name="use-the-latest-aspnet-core-release"></a>Использование последней версии ASP.NET Core

Каждый новый выпуск ASP.NET Core включает улучшения производительности. Оптимизация в .NET Core и ASP.NET Core означает, что более новые версии обычно более эффективны старые версии. Например, в .NET Core 2,1 добавлена поддержка скомпилированных регулярных выражений и выиграли из [диапазона\<t >](https://msdn.microsoft.com/magazine/mt814808.aspx). В ASP.NET Core 2,2 добавлена поддержка HTTP/2. [ASP.NET Core 3,0 добавляет множество улучшений](xref:aspnetcore-3.0) , которые уменьшают использование памяти и увеличивают пропускную способность. Если производительность является приоритетной, рассмотрите возможность обновления до текущей версии ASP.NET Core.

## <a name="minimize-exceptions"></a>Уменьшение числа исключений

Исключения должны быть редкими. Создание и перехват исключений происходит очень долго относительно других шаблонов потока кода. Поэтому исключения не должны использоваться для управления нормальным выполнением программы.

Рекомендации:

* **Не** используйте генерацию или перехват исключений в качестве средства обычного потока программы, особенно в [путях горячего кода](#understand-hot-code-paths).
* **Включите в** приложение логику для обнаружения и обработки условий, вызывающих исключение.
* **Вызывайте или** перехватите исключения для необычных или непредвиденных условий.

Средства диагностики приложений, такие как Application Insights, могут помочь в определении распространенных исключений в приложении, которое может повлиять на производительность.

## <a name="performance-and-reliability"></a>Производительность и надежность

Следующие разделы содержат советы по повышению производительности и известным проблемам надежности и решениям.

## <a name="avoid-synchronous-read-or-write-on-httprequesthttpresponse-body"></a>Избегайте синхронного чтения или записи в тексте HttpRequest/HttpResponse

Все операции ввода-вывода в ASP.NET Core являются асинхронными. Серверы реализуют интерфейс `Stream`, который имеет как синхронные, так и асинхронные перегрузки. Асинхронные объекты должны быть предпочтительнее, чтобы избежать блокирования потоков пула потоков. Блокировка потоков может привести к нехватке пула потоков.

Не Выменяйте **это:** В следующем примере используется <xref:System.IO.StreamReader.ReadToEnd*>. Он блокирует текущий поток для ожидания результата. Это пример [синхронизации через Async](https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#warning-sync-over-async
).

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/MyFirstController.cs?name=snippet1)]

В приведенном выше коде `Get` синхронно считывает весь текст HTTP-запроса в память. Если клиент медленно отправляется, приложение выполняет синхронизацию асинхронно. Приложение выполняет синхронизацию асинхронно, так как Kestrel **не поддерживает** синхронные операции чтения.

**Выполните следующие действия.** В следующем примере используется <xref:System.IO.StreamReader.ReadToEndAsync*> и не блокируется поток при чтении.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/MyFirstController.cs?name=snippet2)]

Приведенный выше код асинхронно считывает весь текст HTTP-запроса в память.

> [!WARNING]
> Если запрос имеет большой размер, чтение всего текста HTTP-запроса в память может привести к нехватке памяти. Сбой может привести к отказу в обслуживании.  Дополнительные сведения см. в разделе [избежание считывания текста большого запроса или тела ответа в память](#arlb) в этом документе.

**Выполните следующие действия.** Следующий пример полностью асинхронно использует текст запроса без буферизации:

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/MyFirstController.cs?name=snippet3)]

Приведенный выше код асинхронно десериализует текст запроса в C# объект.

## <a name="prefer-readformasync-over-requestform"></a>Предпочитать Реадформасинк по запросу. Form

Используйте `HttpContext.Request.ReadFormAsync` вместо `HttpContext.Request.Form`.
`HttpContext.Request.Form` может быть безопасно прочитана только со следующими условиями:

* Форма была считана вызовом `ReadFormAsync`и
* Кэшированное значение формы считывается с помощью `HttpContext.Request.Form`

Не Выменяйте **это:** В следующем примере используется `HttpContext.Request.Form`.  `HttpContext.Request.Form` использует [синхронизацию асинхронно](https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#warning-sync-over-async
) и может привести к нехватке пула потоков.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/MySecondController.cs?name=snippet1)]

**Выполните следующие действия.** В следующем примере `HttpContext.Request.ReadFormAsync` используется для асинхронного чтения текста формы.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/MySecondController.cs?name=snippet2)]

<a name="arlb"></a>

## <a name="avoid-reading-large-request-bodies-or-response-bodies-into-memory"></a>Избегайте считывания текста крупного запроса или тела ответа в память

В .NET каждое выделение объектов, превышающее 85 КБ, заканчивается в куче больших объектов ([LOH](https://blogs.msdn.microsoft.com/maoni/2006/04/19/large-object-heap/)). Большие объекты являются ресурсоемкими двумя способами:

* Стоимость выделения высока, так как память для вновь выделенного большого объекта должна быть сброшена. Среда CLR гарантирует, что память для всех вновь выделяемых объектов будет сброшена.
* LOH собирается вместе с остальной частью кучи. Для LOH требуется полная сборка [мусора](/dotnet/standard/garbage-collection/fundamentals) или [коллекция Gen2](/dotnet/standard/garbage-collection/fundamentals#generations).

Эта [запись блога](https://adamsitnik.com/Array-Pool/#the-problem) кратко описывает проблему:

> При выделении большого объекта он помечается как объект Gen 2. Не Gen 0 как для небольших объектов. Последствия в том, что если в LOH исчерпана память, сборщик мусора очищает всю управляемую кучу, а не только LOH. Он очищает Gen 0, Gen 1 и Gen 2, включая LOH. Это называется полной сборкой мусора и является наиболее длительным сбором мусора. Для многих приложений это может быть приемлемым. Но определенно не для высокопроизводительных веб-серверов, где несколько больших буферов памяти требуются для обработки среднего веб-запроса (чтение из сокета, распаковка, декодирование JSON & больше).

Простое хранение большого запроса или текста ответа в одном `byte[]` или `string`:

* Может привести к быстрому запуску пространства в LOH.
* Может вызвать проблемы с производительностью приложения из-за выполнения полных GC.

## <a name="working-with-a-synchronous-data-processing-api"></a>Работа с синхронным интерфейсом API обработки данных

При использовании сериализатора или отмены сериализатора, поддерживающего только синхронные операции чтения и записи (например, [JSON.NET](https://www.newtonsoft.com/json/help/html/Introduction.htm)):

* Асинхронная буферизация данных в память перед их передачей в сериализатор/de-сериализатор.

> [!WARNING]
> Если запрос большой, это может привести к нехватке памяти («нехватки»). Сбой может привести к отказу в обслуживании.  Дополнительные сведения см. в разделе [избежание считывания текста большого запроса или тела ответа в память](#arlb) в этом документе.

ASP.NET Core 3,0 по умолчанию использует <xref:System.Text.Json> для сериализации JSON. <xref:System.Text.Json>.

* асинхронно считывает и записывает JSON;
* оптимизирован для текста UTF-8;
* предоставляет более высокую производительность, чем `Newtonsoft.Json`.

## <a name="do-not-store-ihttpcontextaccessorhttpcontext-in-a-field"></a>Не хранить Ихттпконтекстакцессор. HttpContext в поле

[Ихттпконтекстакцессор. HttpContext](xref:Microsoft.AspNetCore.Http.IHttpContextAccessor.HttpContext) возвращает `HttpContext` активного запроса при доступе из потока запроса. `IHttpContextAccessor.HttpContext` **не** должны храниться в поле или переменной.

Не Выменяйте **это:** В следующем примере `HttpContext` сохраняется в поле, а затем попытается использовать его позже.

[!code-csharp[](performance-best-practices/samples/3.0/MyType.cs?name=snippet1)]

В приведенном выше коде часто записывается значение null или неверный `HttpContext` в конструкторе.

**Выполните следующие действия.** Следующий пример:

* Хранит <xref:Microsoft.AspNetCore.Http.IHttpContextAccessor> в поле.
* Использует поле `HttpContext` в нужное время и проверяет наличие `null`.

[!code-csharp[](performance-best-practices/samples/3.0/MyType.cs?name=snippet2)]

## <a name="do-not-access-httpcontext-from-multiple-threads"></a>Не обращаться к HttpContext из нескольких потоков

`HttpContext` *не* является потокобезопасным. Параллельный доступ к `HttpContext` из нескольких потоков может привести к неопределенному поведению, такому как зависание, сбои и повреждение данных.

Не Выменяйте **это:** В следующем примере выполняется три параллельных запроса и записывается путь к входящему запросу до и после исходящего HTTP-запроса. Доступ к пути запроса осуществляется из нескольких потоков, которые могут быть параллельными.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/AsyncFirstController.cs?name=snippet1&highlight=25,28)]

**Выполните следующие действия.** В следующем примере все данные из входящего запроса копируются перед выполнением трех параллельных запросов.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/AsyncFirstController.cs?name=snippet2&highlight=6,8,22,28)]

## <a name="do-not-use-the-httpcontext-after-the-request-is-complete"></a>Не используйте HttpContext после завершения запроса

`HttpContext` допустимо только при условии, что в конвейере ASP.NET Core есть активный HTTP-запрос. Весь конвейер ASP.NET Core является асинхронной цепочкой делегатов, выполняющих каждый запрос. После завершения `Task`, возвращенного из этой цепочки, `HttpContext` перезапускается.

Не Выменяйте **это:** В следующем примере используется `async void`, который делает HTTP-запрос завершенным при достижении первого `await`:

* Это **всегда** является неправильной практикой в ASP.NET Core приложениях.
* Обращается к `HttpResponse` после завершения HTTP-запроса.
* Завершается сбоем процесса.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/AsyncBadVoidController.cs?name=snippet1)]

**Выполните следующие действия.** В следующем примере возвращается `Task` платформе, поэтому HTTP-запрос не завершается до завершения действия.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/AsyncSecondController.cs?name=snippet1)]

## <a name="do-not-capture-the-httpcontext-in-background-threads"></a>Не захватывать HttpContext в фоновых потоках

Не Выменяйте **это:** В следующем примере показано закрытие `HttpContext` из свойства `Controller`. Это неплохая практика, поскольку рабочий элемент может:

* Выполнение за пределами области запроса.
* Попытка прочитать неправильный `HttpContext`.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/FireAndForgetFirstController.cs?name=snippet1)]

**Выполните следующие действия.** Следующий пример:

* Копирует данные, необходимые в фоновой задаче, во время запроса.
* Не ссылается на что-либо из контроллера.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/FireAndForgetFirstController.cs?name=snippet2)]

Фоновые задачи должны быть реализованы как размещенные службы. Дополнительные сведения см. в статье [Background tasks with hosted services in ASP.NET Core](xref:fundamentals/host/hosted-services) (Фоновые задачи с размещенными службами в ASP.NET Core).

## <a name="do-not-capture-services-injected-into-the-controllers-on-background-threads"></a>Не захватывать службы, внедренные в контроллеры в фоновых потоках

Не Выменяйте **это:** В следующем примере показано закрытие `DbContext` из параметра действия `Controller`. Это неплохой подход.  Рабочий элемент может выполняться вне области запроса. `ContosoDbContext` ограничивается запросом, что приводит к `ObjectDisposedException`.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/FireAndForgetSecondController.cs?name=snippet1)]

**Выполните следующие действия.** Следующий пример:

* Внедряет <xref:Microsoft.Extensions.DependencyInjection.IServiceScopeFactory>, чтобы создать область в фоновом рабочем элементе. `IServiceScopeFactory` является Singleton-классом.
* Создает новую область внедрения зависимостей в фоновом потоке.
* Не ссылается на что-либо из контроллера.
* Не захватывает `ContosoDbContext` из входящего запроса.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/FireAndForgetSecondController.cs?name=snippet2)]

Выделенный ниже код:

* Создает область в течение времени существования фоновой операции и разрешает службы из нее.
* Использует `ContosoDbContext` из правильной области действия.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/FireAndForgetSecondController.cs?name=snippet2&highlight=9-16)]

## <a name="do-not-modify-the-status-code-or-headers-after-the-response-body-has-started"></a>Не изменяйте код состояния или заголовки после начала текста ответа

ASP.NET Core не замещает текст HTTP-ответа. При первом написании ответа:

* Заголовки отправляются клиенту вместе с этим фрагментом текста.
* Больше нельзя изменять заголовки ответа.

Не Выменяйте **это:** Следующий код пытается добавить заголовки ответа после того, как ответ уже запущен:

[!code-csharp[](performance-best-practices/samples/3.0/Startup22.cs?name=snippet1)]

В приведенном выше коде `context.Response.Headers["test"] = "test value";` выдаст исключение, если `next()` записал в ответ.

**Выполните следующие действия.** В следующем примере проверяется, начался ли HTTP-ответ перед изменением заголовков.

[!code-csharp[](performance-best-practices/samples/3.0/Startup22.cs?name=snippet2)]

**Выполните следующие действия.** В следующем примере используется `HttpResponse.OnStarting` для установки заголовков перед очисткой заголовков ответа клиенту.

Проверка того, что ответ не запущен, позволяет регистрировать обратный вызов, который будет вызываться непосредственно перед заголовком ответа. Проверяется, не начался ли ответ:

* Предоставляет возможность добавлять или переопределять заголовки по времени.
* Не требует знания следующего по промежуточного слоя в конвейере.

[!code-csharp[](performance-best-practices/samples/3.0/Startup22.cs?name=snippet3)]

## <a name="do-not-call-next-if-you-have-already-started-writing-to-the-response-body"></a>Не вызывайте Next (), если вы уже начали записывать в текст ответа.

Компоненты должны вызываться, только если они могут обрабатывать ответ и управлять им.
